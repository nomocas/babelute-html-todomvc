{"version":3,"file":"app.js","sources":["../node_modules/event-emitter-es6/index.js","../src/store.js","../../babelute/src/babelute.js","../../babelute/src/lexicon/first-level.js","../../babelute/src/lexicon/lexicon.js","../../babelute/src/pragmatics/pragmatics-core.js","../../babelute/src/pragmatics/pragmatics-scopes.js","../../babelute/src/pragmatics/facade-pragmatics.js","../../babelute/src/index.js","../../babelute-html/src/pragmatics/dom-utils.js","../../babelute-html/src/html-lexicon.js","../src/todomvc-html-lexicon.js","../../babelute-html/src/pragmatics/html-to-dom-diffing.js","../src/index.js"],"sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DEFAULT_VALUES = {\n    emitDelay: 10,\n    strictMode: false\n};\n\n/**\n * @typedef {object} EventEmitterListenerFunc\n * @property {boolean} once\n * @property {function} fn\n */\n\n/**\n * @class EventEmitter\n *\n * @private\n * @property {Object.<string, EventEmitterListenerFunc[]>} _listeners\n * @property {string[]} events\n */\n\nvar EventEmitter = function () {\n\n    /**\n     * @constructor\n     * @param {{}}      [opts]\n     * @param {number}  [opts.emitDelay = 10] - Number in ms. Specifies whether emit will be sync or async. By default - 10ms. If 0 - fires sync\n     * @param {boolean} [opts.strictMode = false] - is true, Emitter throws error on emit error with no listeners\n     */\n\n    function EventEmitter() {\n        var opts = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_VALUES : arguments[0];\n\n        _classCallCheck(this, EventEmitter);\n\n        var emitDelay = void 0,\n            strictMode = void 0;\n\n        if (opts.hasOwnProperty('emitDelay')) {\n            emitDelay = opts.emitDelay;\n        } else {\n            emitDelay = DEFAULT_VALUES.emitDelay;\n        }\n        this._emitDelay = emitDelay;\n\n        if (opts.hasOwnProperty('strictMode')) {\n            strictMode = opts.strictMode;\n        } else {\n            strictMode = DEFAULT_VALUES.strictMode;\n        }\n        this._strictMode = strictMode;\n\n        this._listeners = {};\n        this.events = [];\n    }\n\n    /**\n     * @protected\n     * @param {string} type\n     * @param {function} listener\n     * @param {boolean} [once = false]\n     */\n\n\n    _createClass(EventEmitter, [{\n        key: '_addListenner',\n        value: function _addListenner(type, listener, once) {\n            if (typeof listener !== 'function') {\n                throw TypeError('listener must be a function');\n            }\n\n            if (this.events.indexOf(type) === -1) {\n                this._listeners[type] = [{\n                    once: once,\n                    fn: listener\n                }];\n                this.events.push(type);\n            } else {\n                this._listeners[type].push({\n                    once: once,\n                    fn: listener\n                });\n            }\n        }\n\n        /**\n         * Subscribes on event type specified function\n         * @param {string} type\n         * @param {function} listener\n         */\n\n    }, {\n        key: 'on',\n        value: function on(type, listener) {\n            this._addListenner(type, listener, false);\n        }\n\n        /**\n         * Subscribes on event type specified function to fire only once\n         * @param {string} type\n         * @param {function} listener\n         */\n\n    }, {\n        key: 'once',\n        value: function once(type, listener) {\n            this._addListenner(type, listener, true);\n        }\n\n        /**\n         * Removes event with specified type. If specified listenerFunc - deletes only one listener of specified type\n         * @param {string} eventType\n         * @param {function} [listenerFunc]\n         */\n\n    }, {\n        key: 'off',\n        value: function off(eventType, listenerFunc) {\n            var _this = this;\n\n            var typeIndex = this.events.indexOf(eventType);\n            var hasType = eventType && typeIndex !== -1;\n\n            if (hasType) {\n                if (!listenerFunc) {\n                    delete this._listeners[eventType];\n                    this.events.splice(typeIndex, 1);\n                } else {\n                    (function () {\n                        var removedEvents = [];\n                        var typeListeners = _this._listeners[eventType];\n\n                        typeListeners.forEach(\n                        /**\n                         * @param {EventEmitterListenerFunc} fn\n                         * @param {number} idx\n                         */\n                        function (fn, idx) {\n                            if (fn.fn === listenerFunc) {\n                                removedEvents.unshift(idx);\n                            }\n                        });\n\n                        removedEvents.forEach(function (idx) {\n                            typeListeners.splice(idx, 1);\n                        });\n\n                        if (!typeListeners.length) {\n                            _this.events.splice(typeIndex, 1);\n                            delete _this._listeners[eventType];\n                        }\n                    })();\n                }\n            }\n        }\n\n        /**\n         * Applies arguments to specified event type\n         * @param {string} eventType\n         * @param {*[]} eventArguments\n         * @protected\n         */\n\n    }, {\n        key: '_applyEvents',\n        value: function _applyEvents(eventType, eventArguments) {\n            var typeListeners = this._listeners[eventType];\n\n            if (!typeListeners || !typeListeners.length) {\n                if (this._strictMode) {\n                    throw 'No listeners specified for event: ' + eventType;\n                } else {\n                    return;\n                }\n            }\n\n            var removableListeners = [];\n            typeListeners.forEach(function (eeListener, idx) {\n                eeListener.fn.apply(null, eventArguments);\n                if (eeListener.once) {\n                    removableListeners.unshift(idx);\n                }\n            });\n\n            removableListeners.forEach(function (idx) {\n                typeListeners.splice(idx, 1);\n            });\n        }\n\n        /**\n         * Emits event with specified type and params.\n         * @param {string} type\n         * @param eventArgs\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(type) {\n            var _this2 = this;\n\n            for (var _len = arguments.length, eventArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                eventArgs[_key - 1] = arguments[_key];\n            }\n\n            if (this._emitDelay) {\n                setTimeout(function () {\n                    _this2._applyEvents.call(_this2, type, eventArgs);\n                }, this._emitDelay);\n            } else {\n                this._applyEvents(type, eventArgs);\n            }\n        }\n\n        /**\n         * Emits event with specified type and params synchronously.\n         * @param {string} type\n         * @param eventArgs\n         */\n\n    }, {\n        key: 'emitSync',\n        value: function emitSync(type) {\n            for (var _len2 = arguments.length, eventArgs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                eventArgs[_key2 - 1] = arguments[_key2];\n            }\n\n            this._applyEvents(type, eventArgs);\n        }\n\n        /**\n         * Destroys EventEmitter\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._listeners = {};\n            this.events = [];\n        }\n    }]);\n\n    return EventEmitter;\n}();\n\nmodule.exports = EventEmitter;\n","/**\n * Simple Naive \"Immutable\" Todo Store.\n * @author Gilles Coomans\n */\n\nimport EventEmitter from 'event-emitter-es6';\n\nconst Todos = new EventEmitter(),\n\tproto = {\n\t\ttodos: [],\n\t\troute: 'all',\n\t\tID: 0,\n\t\tmethods: {\n\t\t\tappend(title) {\n\t\t\t\tthis.todos = this.todos.concat({\n\t\t\t\t\ttitle: title || '',\n\t\t\t\t\tid: this.ID++,\n\t\t\t\t\tcompleted: false\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\tprepend(title) {\n\t\t\t\tthis.todos = [{\n\t\t\t\t\ttitle: title || '',\n\t\t\t\t\tid: this.ID++,\n\t\t\t\t\tcompleted: false\n\t\t\t\t}].concat(this.todos);\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\tdelete(id) {\n\t\t\t\tthis.todos = this.todos.filter((todo) => {\n\t\t\t\t\treturn todo.id !== id;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\ttoggleComplete(id) {\n\t\t\t\tthis.todos = this.todos.map((todo) => {\n\t\t\t\t\tif (todo.id === id) {\n\t\t\t\t\t\ttodo = Object.assign({}, todo);\n\t\t\t\t\t\ttodo.completed = !todo.completed;\n\t\t\t\t\t}\n\t\t\t\t\treturn todo;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\tupdateTitle(id, title) {\n\t\t\t\tthis.todos = this.todos.map((todo) => {\n\t\t\t\t\tif (todo.id === id && todo.title !== title) {\n\t\t\t\t\t\ttodo = Object.assign({}, todo);\n\t\t\t\t\t\ttodo.title = title;\n\t\t\t\t\t}\n\t\t\t\t\treturn todo;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\tclearCompleted() {\n\t\t\t\tthis.todos = this.todos.filter((todo) => {\n\t\t\t\t\treturn !todo.completed;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\ttoggleAll() {\n\t\t\t\tthis.todos = this.todos.map((todo) => {\n\t\t\t\t\ttodo = Object.assign({}, todo);\n\t\t\t\t\ttodo.completed = !todo.completed;\n\t\t\t\t\treturn todo;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t}\n\t\t}\n\t};\n\n// copy proto\nfor (const i in proto)\n\tTodos[i] = proto[i];\n\n// bind all methods to root\nfor (const i in Todos.methods)\n\tTodos.methods[i] = Todos.methods[i].bind(Todos);\n\nexport default Todos;\n\n//","/**\n * Babelute core\n *\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\n\n/**\n * Lexem class : a lexem is just an object containing 3 properties { lexicon:String, name:String, args:Arguments|Array }\n * You should never construct them directly (but if you do babelute's plugins). And it should never be extended.\n * @protected\n */\nexport class Lexem {\n\n\t/**\n\t * construct a new lexem instance\n\t * @param  {String} lexicon the lexicon's name of the lexem\n\t * @param  {String} name    the lexem's name\n\t * @param  {Array|arguments} args  the lexem's arguments (an array or the \"callee arguments\" object) \n\t */\n\tconstructor(lexicon, name, args) {\n\t\tassert(typeof lexicon === 'string' && lexicon.length, 'Lexicon\\'s name should be a valid string');\n\t\tassert(typeof name === 'string' && lexicon.length, 'Lexem\\'s name should be a valid string');\n\t\tassert(Array.isArray(args) || typeof args.length !== 'undefined', 'Lexem\\'s args should be an array (or iterable with bracket access)');\n\n\t\t/**\n\t\t * the lexicon name from where the lexem comes\n\t\t * @type {String}\n\t\t */\n\t\tthis.lexicon = lexicon;\n\n\t\t/**\n\t\t * the lexem's name\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The lexem's arguments array (or arguments object)\n\t\t * @type {Array|arguments}\n\t\t */\n\t\tthis.args = args;\n\t}\n}\n\n/**\n * Babelute subclass(es) : for holding DSL's API.\n * \n * Babelute subclass(es) instances : for holding array of lexems (i.e. a sentence) written through the DSL's API.\n *\n * Will be the base class for all DSLs handlers.\n *\n * Babelute API and lexems Naming Conventions : \n * \n * - any \"meta-language\" method (aka any method that handle the sentence it self - appending new lexem, changing current lexicon, sentences translations, ...) \n * must start with and underscore : e.g. _append, _lexicon, _if,  _each, _eachLexem, _translate...\n * - any \"pragmatics output related\" method should start with a '$' and should be named with followed format : e.g. .$myLexiconToMyOutputType(...)\n * - any DSL lexems (so any other \"api\"'s method) should start with a simple alphabetic char : e.g. .myLexem(), .description(), .title(), ...\n * \t\t\n * @public\n */\nexport class Babelute {\n\n\t/**\n\t * construct a babelute instance\n\t * @param  {?Array} lexems array of lexems for init. (only for internal use)\n\t */\n\tconstructor(lexems = null) {\n\t\tassert(!lexems || Array.isArray(lexems), 'Babelute\\'s constructor accept only an array of lexems as argument (optionaly)');\n\n\t\t/**\n\t\t * the array where lexems are stored\n\t\t * @type {Array}\n\t\t */\n\t\tthis._lexems = lexems || [];\n\n\t\t/**\n\t\t * useful marker for fast instanceof replacement (frame/multiple-js-runtime friendly)\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.__babelute__ = true;\n\t}\n\n\t/**\n\t * The absolute Babelute atom method : add a lexem to babelute's array\n\t * @public\n\t * @param  {String} lexiconName the current lexicon name\n\t * @param  {String} name      the lexem's name\n\t * @param  {Array|arguments} args   the lexem's arguments (either an array or maybe directly the arguments object from when lexem is called)\n\t * @return {Babelute} \tthe current Babelute instance\n\t */\n\t_append(lexiconName, name, args) {\n\n\t\tthis._lexems.push(new Lexem(lexiconName, name, args));\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * conditional sentences concatenation.\n\t *\n\t * Apply modification at sentence writing time (aka the babelute does not contains the _if lexems. _if has immediatly been applied).\n\t * \n\t * @public\n\t * @param  {*} condition any value that will be casted to Boolean (!!)\n\t * @param  {Babelute} babelute  which sentence to insert if !!condition === true\n\t * @param  {?Babelute} elseBabelute  which sentence to insert if !!condition === false\n\t * @return {Babelute}     the current Babelute instance\n\t */\n\t_if(condition, babelute, elseBabelute = null) {\n\n\t\tassert(babelute instanceof Babelute, '._if meta-api need an babelute instance as second argument');\n\t\tassert(!elseBabelute || elseBabelute instanceof Babelute, '._if meta-api need an babelute instance as third argument (optional)');\n\n\t\tif (condition)\n\t\t\tthis._lexems = this._lexems.concat(babelute._lexems);\n\t\telse if (elseBabelute)\n\t\t\tthis._lexems = this._lexems.concat(elseBabelute._lexems);\n\t\treturn this;\n\t}\n\n\t/**\n\t * For each item from array : execute function and concatenate returned babelute sentence to current one. \n\t * Provided function must return a babelute.\n\t *\n\t * Apply modification at sentence writing time (aka the babelute does not contains the _each lexems. _each has immediatly been applied).\n\t * \n\t * @public\n\t * @param  {Array} array  the array to iterate on\n\t * @param  {Function} func the function to handle each item. it must return a babelute.\n\t * @return {Babelute}     the current Babelute instance\n\t */\n\t_each(array, func) {\n\n\t\tassert(Array.isArray(array) || array.length, '._each meta-api need an array (or iterable with bracket access) as first argument');\n\t\tassert(typeof func === 'function', '._each meta-api need a function as second argument');\n\n\t\tarray.forEach((item, index) => {\n\t\t\tconst b = func(item, index);\n\n\t\t\tassert(b instanceof Babelute, '._each need a function that return a babelute');\n\n\t\t\tthis._lexems.push.apply(this._lexems, b._lexems);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a babelute (another sentence) at this point in the current sentence\n\t * @public\n\t * @param  {string|Babelute} babelute Either a string formatted as 'mylexicon:myMethod' (which gives the lexem's method to call), or a Babelute instance (which will be inserted in current sentence)\n\t * @param  {?...args} args the optional arguments to use when calling lexem (only if first argument is a string)\n\t * @return {Babelute} the current Babelute instance\n\t * @throws {Error} If lexicon not found (when first arg is string)\n\t * @throws {Error} If method not found in lexicon (when first arg is string)\n\t */\n\t_use(babelute, ...args) { // eslint-disable-line no-unused-vars\n\t\t// will be implemented in lexicon\n\t}\n\n\n\t/**\n\t * Change current lexicon for next lexems\n\t * @public\n\t * @param  {string} lexiconName the lexicon to use\n\t * @return {Babelute}  a new Babelute from lexicon (i.e. with lexicon's API)\n\t * @throws {Error} If lexicon not found with lexiconName\n\t */\n\t_lexicon(lexiconName) { // eslint-disable-line no-unused-vars\n\t\tassert(typeof lexiconName === 'string', '._lexicon need a string as first argument');\n\t\t// will be implemented in lexicon\n\t}\n\n\t/**\n\t * Create Babelute subclass\n\t * @param  {Babelute} BaseClass the class to be extended\n\t * @param  {?Object} api an object containing methods to add to prototype\n\t * @return {Babelute}   The subclass\n\t * @throws {AssertionError} (only in dev mode) If BaseClass is not a Babelute Subclass (or Babelute)\n\t */\n\tstatic extends(BaseClass, api = null) {\n\t\tassert(BaseClass === Babelute || (BaseClass.prototype instanceof Babelute), 'Babelute.extends accepts only a Babelute Class (or subclass) as first argument');\n\t\tassert(!api || typeof api === 'object', 'Babelute.extends need a (optional) valid object containing methods as second argument');\n\t\tconst B = function(lexems) {\n\t\t\tBaseClass.call(this, lexems);\n\t\t};\n\t\tB.prototype = Object.create(BaseClass.prototype);\n\t\tB.prototype.constructor = B;\n\t\tfor (var i in api) // Object.assign seems to bug when used on prototype (not investigate enough : so use plain old for-in syntax)\n\t\t\tB.prototype[i] = api[i];\n\t\treturn B;\n\t}\n}\n\n\n/**\n * deserialize json to babelute\n * @param  {String} json the json string\n * @return {Babelute}      the deserialized babelute\n * @throws {Error} If json is badly formated\n */\nexport function fromJSON(json) {\n\tassert(typeof json === 'string', 'babelute.fromJSON need a string as first argument');\n\treturn JSON.parse(json, (k, v) => {\n\t\tif (v && v.__babelute__)\n\t\t\treturn new Babelute(v._lexems.map((lexem) => {\n\t\t\t\treturn new Lexem(lexem.lexicon, lexem.name, lexem.args);\n\t\t\t}));\n\t\treturn v;\n\t});\n}\n\n","/**\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\nimport {\n\tBabelute,\n\tLexem\n} from '../babelute.js';\n\n/**\n * A FirstLevel is a Babelute that has exactly same api than its corresponding Babelute (from a DSL) but where every compounds methods has been replaced by its \"atomic\" equivalent.\n * (Same concept than 'first-level of understanding', as if we where stupid by always understanding only first literal sens of words.)\n * \n * It provides sentences and lexems without any interpretation, and that could be really useful : e.g.\n * - to see sentence as \"editable document\" and/or for allowing meta-writing of sentences\n * - to obtain the full AST of babelute sentences \n * \n * @access protected\n */\nexport default class FirstLevel extends Babelute {\n\n\t/**\n\t * construct a firstlevel babelute instance\n\t * @param  {?Array} lexems array of lexems for init. (only for internal use)\n\t */\n\tconstructor(lexems) {\n\t\tsuper(lexems);\n\t\tthis.__first_level_babelute__ = true;\n\t}\n\n\t/**\n\t * return a FirstLevelMethod aka a method that only append an atom (lexicon, name, args)\n\t * @param  {String} lexiconName the lexicon name of the appended atom\n\t * @param  {String} lexemName  the lexem name of the appended atom\n\t * @return {Function}           a function that append the atom\n\t */\n\tstatic getFirstLevelMethod(lexiconName, lexemName) {\n\t\tassert(typeof lexiconName === 'string', 'FirstLevel.getFirstLevelMethod(...) need a string (the lexicon name) as first argument');\n\t\tassert(typeof lexemName === 'string', 'FirstLevel.getFirstLevelMethod(...) need a string (the lexem name) as second argument');\n\t\treturn function () {\n\t\t\tthis._lexems.push(new Lexem(lexiconName, lexemName, arguments));\n\t\t\treturn this;\n\t\t};\n\t}\n}","/**\n * Babelute Lexicon class and helpers.\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\n\nimport {\n\tBabelute,\n\tLexem\n} from '../babelute.js';\n\nimport FirstLevel from './first-level.js';\n\n/**\n * Lexicons dico : where to store public lexicon\n * @type {Object}\n * @private\n */\nconst lexicons = {};\n\n/**\n * Way to create lexicon instances\n * @public\n * @param  {string} name   the name of the lexicon\n * @param  {Lexicon} parent a lexicon instance as parent for this one (optional)\n * @return {Lexicon}      a lexicon instance\n */\nfunction createLexicon(name, parent = null) {\n\treturn new Lexicon(name, parent);\n}\n\n/**\n * Lexicon class : helpers to store and manage DSL's API.\n * \n * A __Lexicon__ is just an object aimed to handle, store and construct easily a DSL (its lexic - i.e. the bunch of words that compose it)\n * and its related Atomic/FirstLevel/SecondLevel Babelute subclasses, and their initializers.\n *\n * One DSL = One lexicon.\n *\n * A lexicon could extend another lexicon to manage dialects.\n *\n * You should never use frontaly the constructor (aka never use new Lexicon in  your app). Use createLexicon in place.\n * \n * @protected\n */\nclass Lexicon {\n\n\t/**\n\t * @param  {string} name   the lexicon name\n\t * @param  {?Lexicon} parent an optional parent lexicon to be extended here\n\t */\n\tconstructor(name, parent = null) {\n\n\t\tassert(typeof name === 'string' && name.length, 'Lexicon constructor need a valid name as first argument'); // all assertions will be removed in production\n\t\tassert(!parent || parent instanceof Lexicon, 'Lexicon constructor second (optional) argument should be another Lexicon that will be used as parent');\n\n\t\t/**\n\t\t * the parent lexicon (if any)\n\t\t * @type {Lexicon}\n\t\t * @protected\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * the lexicon's name\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\t\tparent = parent || {};\n\n\t\t// the three APIs :\n\t\t/**\n\t\t * interpretable sentences API (finally always made from syntactical atoms (aka last level))\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.Atomic = initClass(parent.Atomic || Babelute);\n\t\t/**\n\t\t * \"document\" sentences API (first level : aka all methods has been replaced by fake atomic methods)\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.FirstLevel = initClass(parent.FirstLevel || FirstLevel);\n\t\t/**\n\t\t * AST-provider API aka the whole tree between first level and last level. Never use it directly : its used under the hood by {@link developOneLevel} method.\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.SecondLevel = Babelute.extends(parent.SecondLevel || Babelute);\n\n\t\t/**\n\t\t * the atomic initializer instance\n\t\t * @type {Initializer}\n\t\t */\n\t\tthis.initializer = this.Atomic.initializer;\n\n\t\t/**\n\t\t * the first-level initializer instance\n\t\t * @type {Initializer}\n\t\t */\n\t\tthis.firstLevelInitializer = this.FirstLevel.initializer;\n\n\t\t/**\n\t\t * the secondLevel instance\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.secondLevel = new this.SecondLevel();\n\n\t\tif (parent.Atomic)\n\t\t\tObject.keys(parent.Atomic.initializer)\n\t\t\t.forEach((key) => {\n\t\t\t\taddToInitializer(this.Atomic.Initializer, key);\n\t\t\t\taddToInitializer(this.FirstLevel.Initializer, key);\n\t\t\t});\n\t}\n\n\t/**\n\t * add atomic lexem (atoms) to lexicon\n\t * @param {string[]} atomsArray array of atoms name (as string)\n\t * @return {Lexicon} the lexicon itself\n\t */\n\taddAtoms(atomsArray) {\n\n\t\tassert(Array.isArray(atomsArray), 'lexicon.addAtoms(...) need an array as first argument');\n\n\t\tatomsArray.forEach((name) => addAtom(this, name));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * add compounds lexems to lexicon\n\t * @param {Function} producer a function that take a babelute initializer as argument and that return an object containing methods (lexems) to add to lexicon\n\t * @return {Lexicon} the lexicon itself\n\t */\n\taddCompounds(producer) {\n\n\t\tassert(typeof producer === 'function', 'lexicon.addCompounds(...) need a function (that return an object containing dsl methods) as first argument');\n\n\t\t// Atomic API is produced with Atomic initializer\n\t\tconst atomicMethods = producer(this.Atomic.initializer);\n\n\t\tassert(atomicMethods && typeof atomicMethods === 'object', 'lexicon.addCompounds(function(){...}) need a function that return an object containing dsl methods to add');\n\n\t\tfor (let i in atomicMethods)\n\t\t\tthis.Atomic.prototype[i] = atomicMethods[i];\n\n\t\t// SecondLevel API is simply produced with the related FirstLevel initializer. \n\t\t// (so same producer method, same api, but different handler for inner composition)\n\t\t// is the only thing to do to gain capability to handle full AST. (see docs)\n\t\tconst secondLevelCompounds = producer(this.FirstLevel.initializer);\n\t\tfor (let j in secondLevelCompounds)\n\t\t\tthis.SecondLevel.prototype[j] = secondLevelCompounds[j];\n\n\t\tObject.keys(atomicMethods)\n\t\t\t.forEach((key) => {\n\t\t\t\tthis.FirstLevel.prototype[key] = FirstLevel.getFirstLevelMethod(this.name, key);\n\t\t\t\taddToInitializer(this.Atomic.Initializer, key);\n\t\t\t\taddToInitializer(this.FirstLevel.Initializer, key);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @protected\n\t */\n\tuseAtomic(babelute, name, args) {\n\t\tassert(babelute && babelute.__babelute__, 'lexicon.useAtomic(...) need a babelute intance as first argument');\n\t\tassert(typeof name === 'string', 'lexicon.useAtomic(...) need a string (a method name) as second argument');\n\n\t\tif (!this.Atomic.instance[name])\n\t\t\tthrow new Error(`Babelute (${ this.name }) : method not found : ${ name }`);\n\t\tthis.Atomic.instance[name].apply(babelute, args);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\tuseFirstLevel(babelute, name, args) {\n\t\tassert(babelute && babelute.__babelute__, 'lexicon.useFirstLevel(...) need a babelute intance as first argument');\n\t\tassert(typeof name === 'string', 'lexicon.useFirstLevel(...) need a string (a method name) as second argument');\n\n\t\tif (!this.FirstLevel.instance[name])\n\t\t\tthrow new Error(`Babelute (${ this.name }) : method not found : ${ name }`);\n\t\tthis.FirstLevel.instance[name].apply(babelute, args);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\ttranslateToAtomic(babelute, targets) {\n\t\treturn translate(babelute, this.Atomic, targets || this.targets);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\ttranslateToFirstLevel(babelute, targets) {\n\t\treturn translate(babelute, this.FirstLevel, targets || this.targets);\n\t}\n}\n\n/**\n *  Add syntactical atom lexem to lexicon (actually to inner classes that reflect API). A syntactical Atom method is a function that only add one lexem.\n *  @private\n */\nfunction addAtom(lexicon, name) {\n\tassert(lexicon instanceof Lexicon, 'Lexicon addAtom(...) first argument should be a Lexicon where add syntactical atom');\n\tassert(typeof name === 'string', 'Lexicon addAtom(...) need a string (a method name) as second argument');\n\n\tlexicon.Atomic.prototype[name] = lexicon.FirstLevel.prototype[name] = lexicon.SecondLevel.prototype[name] = FirstLevel.getFirstLevelMethod(lexicon.name, name);\n\taddToInitializer(lexicon.Atomic.Initializer, name);\n\taddToInitializer(lexicon.FirstLevel.Initializer, name);\n}\n\n/**\n * babelute lexicon's Classes initialisation\n * @private\n */\nfunction initClass(BaseClass) {\n\tconst Class = Babelute.extends(BaseClass);\n\tcreateInitializer(Class, BaseClass.Initializer);\n\tClass.instance = new Class();\n\treturn Class;\n}\n\n/**\n * Initializer Class\n * @private\n */\nclass Initializer {\n\tstatic extends(BaseInitializer) {\n\n\t\tassert(BaseInitializer === Initializer || (BaseInitializer.prototype instanceof Initializer), 'Initializer.extends accepts only a Initializer Class (or subclass) as argument');\n\n\t\tconst Class = function() {};\n\t\tClass.prototype = Object.create(BaseInitializer.prototype);\n\t\tClass.prototype.constructor = Class;\n\t\treturn Class;\n\t}\n}\n\n/**\n * create a Initializer (based on a Babelute subclass) and instanciate it\n * @param  {Babelute} BabeluteClass   a Babelute subclass from where create initializer\n * @param  {?Initializer} BaseInitializer a parent initializer to be extended (optional)\n * @return {Initializer}               the Initializer instance\n */\nfunction createInitializer(BabeluteClass, BaseInitializer = null) {\n\n\tassert(BabeluteClass === Babelute || (BabeluteClass.prototype instanceof Babelute), 'Lexicon createInitializer accepts only a Babelute Class (or subclass) as first argument');\n\tassert(!BaseInitializer || BaseInitializer === Initializer || (BaseInitializer.prototype instanceof Initializer), 'Lexicon createInitializer accepts only a Initializer Class (or subclass) as second argument');\n\n\tconst Init = BabeluteClass.Initializer = BaseInitializer ? Initializer.extends(BaseInitializer) : Initializer;\n\tBabeluteClass.initializer = new Init();\n\tBabeluteClass.initializer._empty = function() {\n\t\treturn new BabeluteClass();\n\t};\n\tBabeluteClass.initializer.BabeluteClass = BabeluteClass;\n\tObject.keys(BabeluteClass)\n\t\t.forEach((i) => {\n\t\t\taddToInitializer(Init, i);\n\t\t});\n\treturn BabeluteClass.initializer;\n}\n\n/**\n * add method to initializer\n * @private\n * @param {Initializer} Initializer Initializer class where add methods in proto\n * @param {string} methodName  the name of method to add\n */\nfunction addToInitializer(Initializer, methodName) {\n\tInitializer.prototype[methodName] = function() {\n\t\treturn this.BabeluteClass.prototype[methodName].apply(new this.BabeluteClass(), arguments);\n\t};\n}\n\n\n/**\n * getLexicon registred lexicon by name\n * \n * @param  {string} lexiconName the lexicon's name\n * @return {Lexicon}      the lexicon\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction getLexicon(lexiconName) {\n\tassert(typeof lexiconName === 'string', 'Lexicon.getLexicon(...) need a string (a lexicon name) as first argument');\n\n\tconst lexicon = lexicons[lexiconName];\n\tif (!lexicon)\n\t\tthrow new Error('lexicon not found : ' + lexiconName);\n\treturn lexicon;\n}\n\n/**\n * registerLexicon lexicon by name\n * @param  {Lexicon} lexicon the lexicon instance to registerLexicon\n * @param  {?string} name    lexicon name (optional : if not provided : use the one from lexicon itself)\n */\nfunction registerLexicon(lexicon, name = null) {\n\tassert(lexicon instanceof Lexicon, 'Lexicon.registerLexicon(...) first argument should be a Lexicon');\n\tassert(!name || typeof name === 'string', 'Lexicon.registerLexicon(...) need a string (a lexicon name) as second argument');\n\n\tlexicons[name || lexicon.name] = lexicon;\n}\n\n\n/**\n * Provide Babelute Subclass \"initializer\" object (the one with all the flattened shortcut api for starting sentences easily)\n * @param  {string} lexiconName The lexiconName where catch the Babelute Class from where getLexicon or create the initializer object.\n * @param  {boolean} asFirstLevel true if should return a first-level instance. false to return an atomic instance.\n * @return {Object}   An initializer object with shortcuted API from lexicon's Atomic prototype\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction initializer(lexiconName, asFirstLevel) {\n\tassert(typeof lexiconName === 'string', 'Babelute.initializer(...) accept only a string (a Lexicon id) as argument');\n\tif (!asFirstLevel)\n\t\treturn getLexicon(lexiconName).Atomic.initializer;\n\treturn getLexicon(lexiconName).FirstLevel.initializer;\n}\n\n\n/*\n * _lexicon handeling\n */\n\n// implementation of already declared method in Babelute's proto\nBabelute.prototype._lexicon = function(lexiconName) {\n\tassert(typeof lexiconName === 'string', '._lexicon(...) accept only a string (a Lexicon id) as argument');\n\n\treturn new(getLexicon(lexiconName).Atomic)(this._lexems);\n};\n\nFirstLevel.prototype._lexicon = function(lexiconName) {\n\tassert(typeof lexiconName === 'string', '._lexicon(...) accept only a string (a Lexicon id) as argument');\n\treturn new(getLexicon(lexiconName).FirstLevel)(this._lexems);\n};\n\n\n/**\n * _use handeling\n */\n\n// implementation of already declared method in Babelute's proto\nBabelute.prototype._use = function(babelute /* could be a string in \"lexiconName:methodName\" format */ , ...args) {\n\tassert(!babelute || typeof babelute === 'string' || babelute.__babelute__);\n\treturn babelute ? use(this, babelute, args, false) : this;\n};\n\n// implementation of already declared method in Babelute's proto\nFirstLevel.prototype._use = function(babelute /* could be a string in \"lexiconName:methodName\" format */ /*, ...args */ ) {\n\tassert(!babelute || typeof babelute === 'string' || babelute.__babelute__);\n\treturn babelute ? use(this, babelute, [].slice.call(arguments, 1), true) : this;\n};\n\nfunction use(self, babelute, args, firstLevel) {\n\tif (typeof babelute === 'string') {\n\t\tconst {\n\t\t\tlexiconName,\n\t\t\tmethodName\n\t\t} = babelute.split(':');\n\t\tgetLexicon(lexiconName)[firstLevel ? 'useFirstLevel' : 'useAtomic'](self, methodName, args);\n\t} else if (babelute.__babelute__)\n\t\tself._lexems = self._lexems.concat(babelute._lexems);\n\treturn self;\n}\n\n/**\n * Translation\n */\nfunction translate(babelute, BabeluteClass, targets) {\n\tconst b = new BabeluteClass();\n\tbabelute._lexems.forEach(function(lexem) {\n\t\tif ((targets && !targets[lexem.lexicon]) || this[lexem.name]) // simply forwards lexem (copy) if not in targets\n\t\t\tthis._lexems.push(new Lexem(lexem.lexicon, lexem.name, lexem.args));\n\t\telse\n\t\t\tthis[lexem.name].apply(this, lexem.args.map((value) => {\n\t\t\t\tif (!value || !value.__babelute__)\n\t\t\t\t\treturn value;\n\t\t\t\treturn translate(value, BabeluteClass, targets);\n\t\t\t}));\n\t}, b);\n\treturn b;\n}\n\n/**\n * return a new babelute from needed lexicon\n * @param  {string} lexiconName             the lexicon from where to take api\n * @param  {Boolean} asFirstLevel  True if it needs to return a FirstLevel instance. False or ommitted : returns an Atomic instance.\n * @return {[type]}                  the babelute instance (either an Atomic or a FirstLevel)\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction init(lexiconName, asFirstLevel) {\n\tif (lexiconName)\n\t\treturn new(getLexicon(lexiconName)[asFirstLevel ? 'FirstLevel' : 'Atomic'])();\n\telse if (asFirstLevel)\n\t\treturn new FirstLevel();\n\treturn new Babelute();\n}\n\n/**\n * develop a FirstLevel babelute through SecondLevel API. It means that each lexem will be translate\n * @param  {Lexem} lexem the lexem to develop\n * @return {[type]}       [description]\n * @throws {Error} If lexicon not found with lexem.lexicon\n * @throws {Error} If method not found in lexicon\n */\nfunction developOneLevel(lexem, lexicon = null) {\n\tassert(lexem && lexem.__babelutelexem__, 'lexicon.developOneLevel(...) need a lexem intance as first argument');\n\n\tlexicon = lexicon || getLexicon(lexem.lexicon);\n\n\tassert(lexicon.secondLevel[lexem.name], 'lexicon.developOneLevel(...) : lexem\\'s name not found in its own referenced lexicon');\n\n\treturn lexicon.secondLevel[lexem.name].apply(new lexicon.FirstLevel(), lexem.args);\n}\n\nexport {\n\tLexicon,\n\tcreateLexicon,\n\tinit,\n\tgetLexicon,\n\tregisterLexicon,\n\tinitializer,\n\tdevelopOneLevel\n};\n\n","/**\n * Pragmatics Class : minimal abstract class for homogeneous pragmatics.\n *\n * This is the minimal contract that a pragmatics should satisfy.\n */\n\nimport assert from 'assert'; // removed in production\n\n/**\n * Base class to provide homogeneous Pragmatics format. You should never instanciate a Pragmatics directly with new. use {@link createPragmatics}.\n */\nexport class Pragmatics {\n\n\t/**\n\t * @param  {Object} targets initial targets object\n\t * @param  {Object} pragmas pragmatics methods to add\n\t */\n\tconstructor(targets = {}, pragmas = {}) {\n\n\t\tassert(typeof targets === 'object', 'Pragmatics constructor need an object (the lexicons targets) as first argument');\n\t\tassert(typeof pragmas === 'object', 'Pragmatics constructor need an object (the pragma\\'s base methods) as second argument');\n\n\t\t/**\n\t\t * targets holder object\n\t\t * @type {Object}\n\t\t * @public\n\t\t */\n\t\tthis._targets = targets;\n\n\t\tif(pragmas)\n\t\t\tthis.addPragmas(pragmas);\n\t}\n\n\t/**\n\t * add methods to pragmatics instance\n\t * @param {Object} pragmas an object containing methods to add\n\t */\n\taddPragmas(pragmas) {\n\n\t\tassert(pragmas && typeof pragmas === 'object', 'pragmatics.addPragmas(...) need a valid object (the methods map to add) as argument');\n\n\t\tfor (const i in pragmas)\n\t\t\t/**\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tthis[i] = pragmas[i];\n\t}\n\n\t/* istanbul ignore next */\n\t/**\n\t * the method used to output a babelute through this pragmatics instance\n\t * @abstract\n\t */\n\t$output( /* ... */ ) {\n\t\t// to be overridden\n\t\tassert(false, 'pragmatics.$output should implemented in subclasses');\n\t}\n}\n\n/**\n * return a new Pragmatics instance. Do not forget to implement $output before usage.\n * @param  {Object} targets initial targets object\n * @param  {Object} pragmas pragmatics methods to add\n * @return {Pragmatics}   the Pragmatics instance\n */\nexport function createPragmatics(targets = {}, pragmas = {}) {\n\treturn new Pragmatics(targets, pragmas);\n}\n\n","/*******************************************************\n ************** Babelute Acions Environment ************\n *******************************************************/\n\nimport assert from 'assert'; // removed in production\n\n/**\n * Inner-sentence-scopes manager : hold array as stacks for inner-scopes of sentences (if needed). It's only avaiable in pragmatics, while traversing, and is dependent of what pragmatics do. See babelute-html-view as an example of usage.\n *\n * So its a simple helper aimed to (while interpreting sentences) :\n * - give a space where store/access needed variables.\n * - manage \"inner sentences scopes\" (as current view container, current context, etc).\n *\n * It has to be used carefully after reading this :\n *\n * For certain output types (as in Babelute-html diffing) it has to be \"pure\".\n * (in a functional way of thinking).\n * It means that it should contains nothing else \n * than \"local\" variables produced and managed while interpreting sentences.\n * No outside-sentence variables should be needed to perform the output.\n * And so, two output from the same sentence should be the same.\n *\n * So by example, Babelute-html-view use it to keep track (for managing view's life cycle) \n * of views tree while rendering (with the scope facility prodived here).\n * \n * Views are inner-sentences objects, and so as needed, \n * two render on same babelute-html sentence will provide same output.\n *\n * For other DSL and outputs types, it depends what you want and implement, but be sure of what your doing \n * before introducing outside variables dependencies in sentences interpretations.\n */\nexport default class Scopes {\n\n\t/**\n\t * @param  {?Object} scope initial scope object\n\t */\n\tconstructor(scope = {}) {\n\t\t/**\n\t\t * the scopes holder\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.scope = scope;\n\t}\n\n\n\t/**\n\t * push value to scope[name]\n\t * @param  {string} name \tthe scope name\n\t * @param  {*} value \t\tthe value to push\n\t * @return {number}       \tthe new length to be consistent with array push\n\t */\n\tpush(name, value) {\n\t\tassert(typeof name === 'string', 'Pragmatics Scopes .push(...) need a string (the scope name where push) as first argument');\n\t\tassert(typeof value !== 'undefined', 'Pragmatics Scopes .push(...) need a value as second argument');\n\t\t\n\t\tthis.scope[name] = this.scope[name]  || [];\n\t\treturn this.scope[name].push(value);\n\t}\n\n\t/**\n\t * pop value from scope[name]\n\t * @param  {string} name the scope name to pop\n\t * @return {*}      the popped value\n\t */\n\tpop(name) {\n\t\tassert(typeof name === 'string', 'Pragmatics Scopes .pop(...) need a string (the scope name to pop) as first argument');\n\t\t\n\t\tif (!this.scope[name].length)\n\t\t\treturn;\n\t\treturn this.scope[name].pop();\n\t}\n\n\t/**\n\t * get scope value by name\n\t * @param  {string} name the scope name\n\t * @return {*}      the top value\n\t * @throws {Error} If scope not found with name\n\t */\n\tget(name){\n\t\tassert(typeof name === 'string', 'Pragmatics Scopes .get(...) need a string (the scope name where get top value) as first argument');\n\n\t\tvar scope = this.scope[name];\n\t\tif(!scope)\n\t\t\tthrow new Error(`scope not found with : ${ name }`);\n\t\treturn scope[scope.length - 1];\n\t}\n}\n\n","import assert from 'assert'; // removed in production\nimport {\n\tBabelute\n} from '../babelute.js';\nimport Scopes from './pragmatics-scopes';\nimport { Pragmatics } from './pragmatics-core.js';\n\n/**\n * FacadePragmatics : a facade oriented Pragmatics subclass. You should never instanciate a FacadePragmatics directly with new. use {@link createFacadePragmatics}.\n * @example\n * // Remarque : any lexem's method will be of the following format : \n * function(subject, args, ?scopes){\n * \t// return nothing\n * }\n */\nexport class FacadePragmatics extends Pragmatics {\n\n\t/**\n\t * @param  {Object} targets initial targets object\n\t * @param  {?Object} pragmas pragmatics methods to add\n\t */\n\tconstructor(targets, pragmas = null) {\n\t\tsuper(targets, pragmas);\n\t}\n\n\t/**\n\t * \"each\" facade implementation\n\t * @param  {Object} subject the handled subject\n\t * @param  {Array|arguments} args  the lexem's args : [ collection:Array, itemHandler:Function ]\n\t * @param  {Scopes} scopes  the sentence's scopes instance\n\t * @return {void}         nothing\n\t */\n\teach(subject, args /* collection, itemHandler */ , scopes) {\n\n\t\tassert(typeof subject === 'object', '.each facade pragma need an object as subject (first argument)');\n\t\tassert(Array.isArray(args[0]) || args[0].length, '.each facade pragma need an array (or iterable with bracket access) as first args object (first argument passed to lexem)');\n\t\tassert(typeof args[1] === 'function', '.each facade pragma need a function as second args object (second argument passed to lexem)');\n\t\tconst collec = args[0],\n\t\t\titemHandler = args[1];\n\n\t\tif (collec.length) // no supputation on collection kind : use \"for\"\n\t\t\tfor (let i = 0, len = collec.length, item, templ; i < len; ++i) {\n\t\t\t\titem = collec[i];\n\t\t\t\ttempl = itemHandler(item, i);\n\t\t\t\tif (templ)\n\t\t\t\t\tthis.$output(subject, templ, scopes);\n\t\t\t}\n\t}\n\n\t/**\n\t * \"if\" facade implementation \n\t * @param  {Object} subject the handled subject\n\t * @param  {Array|arguments} args  the lexem's args : [ conditionIsTrue:Babelute, conditionIsFalse:Babelute ]\n\t * @param  {Scopes} scopes  the sentence's scopes instance\n\t * @return {void}         nothing\n\t */\n\tif (subject, args /* trueBabelute, falseBabelute */ , scopes) {\n\n\t\tassert(typeof subject === 'object', '.if facade pragma need an object as subject (first argument)');\n\t\tassert(args[1] instanceof Babelute, '.if facade pragma need an babelute instance as second args object (second argument passed to lexem)');\n\t\tassert(!args[2] || args[2] instanceof Babelute, '.if facade pragma third args object (third argument passed to lexem) (optional) should be a babelute instance');\n\n\t\tif (args[0])\n\t\t\tthis.$output(subject, args[1], scopes);\n\t\telse if (args[2])\n\t\t\tthis.$output(subject, args[2], scopes);\n\t}\n\n\t/**\n\t *\n\t * @override\n\t * @param  {Object} subject  the subject handle through interpretation\n\t * @param  {Babelute} babelute the babelute \"to interpret on\" subject\n\t * @param  {Scope} scopes   the sentence scopes instance (optional)\n\t * @return {Object}        the subject\n\t */\n\t$output(subject, babelute, scopes = null) {\n\n\t\tassert(typeof subject === 'object', '.$output facade pragma need an object as subject (first argument)');\n\t\tassert(babelute instanceof Babelute, '.$output facade pragma need an babelute instance as second argument');\n\t\tassert(!scopes || typeof scopes === 'object', '.$output facade pragma need an (optional) scope instance as third argument');\n\n\t\tfor (let i = 0, lexem, len = babelute._lexems.length; i < len; ++i) {\n\t\t\tlexem = babelute._lexems[i];\n\t\t\tif (this._targets[lexem.lexicon] && this[lexem.name])\n\t\t\t\tthis[lexem.name](subject, lexem.args, scopes);\n\t\t}\n\t\treturn subject;\n\t}\n}\n\n/**\n * create a facade-ready-to-run initializer function.\n * @param  {Lexicon} lexicon    the lexicon from where take the api\n * @param  {Object} pragmatics   the pragmatics object where to find interpretation method to fire immediatly\n * @return {Function}            the facade initializer function\n * @example\n *\n * import babelute from 'babelute';\n * const myLexicon = babelute.createLexicon('my-lexicon');\n * myLexicon.addAtoms(['foo', 'bar']);\n * \n * const myPragmas = babelute.createFacadePragmatics({\n * \t'my-lexicon':true\n * }, {\n * \tfoo(subject, args, scopes){\n * \t\t// do something\n * \t},\n * \tbar(subject, args, scopes){\n * \t\t// do something\n * \t}\n * });\n *\n * const mlp = babelute.createFacadeInitializer(myLexicon, myPragmas);\n *\n * mlp(mySubject).foo(...).bar(...); // apply pragmas immediatly on subject through lexicon api's\n *\n */\nexport function createFacadeInitializer(lexicon, pragmatics) {\n\tconst Facade = function(subject, scopes) {\n\t\tlexicon.Atomic.call(this);\n\t\tthis._subject = subject;\n\t\tthis._scopes = scopes;\n\t};\n\n\tFacade.prototype = Object.create(lexicon.Atomic.prototype);\n\tFacade.prototype.constructor = Facade;\n\tFacade.prototype._lexicon = null;\n\tFacade.prototype._append = function(lexiconName, name, args) {\n\t\tif ((!pragmatics._targets || pragmatics._targets[lexiconName]) && pragmatics[name])\n\t\t\tpragmatics[name](this._subject, args, this._scopes);\n\t\treturn this;\n\t};\n\treturn (subject, scopes = null) => {\n\t\treturn new Facade(subject, scopes || new Scopes());\n\t};\n}\n\n/**\n * create a FacadePragmatics instance\n * @param  {Object} targets the pragmatics targets DSL\n * @param  {?Object} pragmas the methods to add\n * @return {FacadePragmatics}     the facade pragmatics instance\n * @example\n * const myPragmas = babelute.createFacadePragmatics({\n * \t'my-lexicon':true\n * }, {\n * \tfoo(subject, args, scopes){\n * \t\t// do something\n * \t},\n * \tbar(subject, args, scopes){\n * \t\t// do something\n * \t}\n * });\n */\nexport function createFacadePragmatics(targets, pragmas = null) {\n\treturn new FacadePragmatics(targets, pragmas);\n}\n\n","/*\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016 Gilles Coomans\n */\n\n// core classes and functions\nimport {\n\tBabelute,\n\tLexem,\n\tfromJSON\n} from './babelute.js';\nimport {\n\tcreateLexicon,\n\tinit,\n\tgetLexicon,\n\tregisterLexicon,\n\tinitializer,\n\tdevelopOneLevel\n} from './lexicon/lexicon.js';\nimport { Pragmatics, createPragmatics } from './pragmatics/pragmatics-core.js';\nimport { FacadePragmatics, createFacadeInitializer, createFacadePragmatics } from './pragmatics/facade-pragmatics.js';\nimport Scopes from './pragmatics/pragmatics-scopes.js';\n\nexport default {\n\tcreateLexicon,\n\tcreatePragmatics,\n\tcreateFacadeInitializer,\n\tcreateFacadePragmatics,\n\tinit,\n\tinitializer,\n\tgetLexicon,\n\tregisterLexicon,\n\tdevelopOneLevel,\n\tfromJSON,\n\tBabelute,\n\tLexem,\n\tPragmatics,\n\tFacadePragmatics,\n\tScopes\n};\n\n","/*\n * @Author: Gilles Coomans\n */\n\n/**\n * parse and insert html string in node and return created nodes\n * @param  {[type]} content     [description]\n * @param  {[type]} node        [description]\n * @param  {[type]} nextSibling [description]\n * @return {[type]}             [description]\n */\nfunction insertHTML(content, node, nextSibling) {\n\tif (!content)\n\t\treturn;\n\n\t// TODO: use this in place : still to catch iserted elements and manage buggy text nodes (when html start with text node)\n\t// if(nextSibling)\n\t// \tnextSibling.insertAdjacentHTML('beforebegin', content);\n\t// else\n\t// \tnode.insertAdjacentHTML('beforeend', content)\n\n\tconst div = document.createElement('div'),\n\t\telems = [];\n\tlet wrapped;\n\tif (content[0] !== '<') { // to avoid bug of text node that disapear\n\t\tcontent = '<p>' + content + '</p>';\n\t\twrapped = true;\n\t}\n\tdiv.innerHTML = content;\n\tconst parent = wrapped ? div.firstChild : div,\n\t\tchildNodes = [].slice.call(parent.childNodes);\n\tlet frag;\n\tif (nextSibling)\n\t\tfrag = document.createDocumentFragment();\n\tfor (let i = 0, len = childNodes.length, el; i < len; ++i) {\n\t\tel = childNodes[i];\n\t\telems.push(el);\n\t\t(frag || node).appendChild(el);\n\t}\n\tif (nextSibling)\n\t\tnode.insertBefore(frag, nextSibling);\n\treturn elems;\n}\n\n/**\n * cast inner nod value depending on node value\n * @param  {DomElement} node [description]\n * @param  {String} type the needed type of the value\n * @return {*}     the casted value\n */\nfunction castNodeValueTo(node, type) {\n\tswitch (type) {\n\t\tcase 'text':\n\t\t\treturn node.textContent;\n\t\tcase 'integer':\n\t\t\treturn parseInt(node.textContent, 10);\n\t\tcase 'html':\n\t\t\treturn node.innerHTML;\n\t\tdefault:\n\t\t\tthrow new Error('content editable casting fail : unrecognised rule : ', type);\n\t}\n}\n\nexport {\n\tinsertHTML,\n\tcastNodeValueTo\n};\n\n","/**\n * ***** Babelute HTML5 DSL lexicon *****\n *\n * \n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n/**\n * @external {Lexicon} https://github.com/nomocas/babelute\n */\nimport { createLexicon } from 'babelute/src/lexicon/lexicon';\nimport { castNodeValueTo } from './pragmatics/dom-utils'; // only used in contentEditable. safe for server and string output usage.\n\n/**\n * html lexicon\n * @type {Lexicon}\n * @public\n * @see  https://github.com/nomocas/babelute-html\n */\nconst htmlLexicon = createLexicon('html');\n\n/*******\n *******\tLANGUAGE ATOMS\n *******/\nhtmlLexicon.atomsList = ['tag', 'attr', 'prop', 'data', 'class', 'id', 'style', 'text', 'on', 'onDom', 'onString', 'if', 'each', 'keyedEach', 'html']; // for convinience\n\nhtmlLexicon.addAtoms(htmlLexicon.atomsList);\n\n/*******\n *******\tCOMPOUNDS WORDS (based on language atoms)\n *******/\n// simple tags (made with .tag) (list should be completed)\nhtmlLexicon.tagsList = ['body', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'section', 'span', 'button', 'main', 'article', 'hr', 'header', 'footer', 'label', 'ul', 'li', 'p', 'small', 'b', 'strong', 'i', 'u', 'select', 'title', 'meta', 'table', 'tr', 'td'];\n// events (made with .on) (list should be completed)\nhtmlLexicon.eventsList = ['click', 'blur', 'focus', 'submit', 'mouseover', 'mousedown', 'mouseup', 'mouseout', 'touchstart', 'touchend', 'touchcancel', 'touchleave', 'touchmove', 'drop', 'dragover', 'dragstart'];\n\nhtmlLexicon\n\t.addCompounds(() => {\n\t\tconst methods = {};\n\t\thtmlLexicon.tagsList.forEach((tagName) => {\n\t\t\tmethods[tagName] = function() {\n\t\t\t\treturn this._append('html', 'tag', [tagName, arguments]);\n\t\t\t};\n\t\t});\n\t\thtmlLexicon.eventsList.forEach((eventName) => {\n\t\t\tmethods[eventName] = function(handler, argument) {\n\t\t\t\treturn this._append('html', 'on', [eventName, handler, argument]);\n\t\t\t};\n\t\t});\n\t\treturn methods;\n\t})\n\t.addCompounds((h) => {\n\t\treturn {\n\t\t\t/**\n\t\t\t * a link tag\n\t\t\t * @public\n\t\t\t * @implements {htmlLexicon}\n\t\t\t * @param  {String} href     the link's href\n\t\t\t * @param  {String} rel      this link's rel\n\t\t\t * @param  {?Babelute} babelute an optional babelute to apply on tag\n\t\t\t * @return {Babelute}          current babelute\n\t\t\t */\n\t\t\tlink(href, rel, babelute) {\n\t\t\t\treturn this.tag('link', [h.attr('href', href).attr('rel', rel), babelute]);\n\t\t\t},\n\t\t\tlinkCSS(href) {\n\t\t\t\treturn this.link(href, 'stylesheet', h.attr('type', 'text/css'));\n\t\t\t},\n\t\t\tinput(type, val, babelute) {\n\t\t\t\treturn this.tag('input', [h.attr('type', type).attr('value', val), babelute]);\n\t\t\t},\n\t\t\ttextInput(val, babelute) {\n\t\t\t\treturn this.input('text', val, babelute);\n\t\t\t},\n\t\t\tpasswordInput(val, babelute) {\n\t\t\t\treturn this.input('password', val, babelute);\n\t\t\t},\n\t\t\tcheckbox(checked, babelute) {\n\t\t\t\treturn this.tag('input', [h.attr('type', 'checkbox').prop('checked', !!checked), babelute]);\n\t\t\t},\n\t\t\tradio(checked, babelute) {\n\t\t\t\treturn this.tag('input', [h.attr('type', 'radio').prop('checked', !!checked), babelute]);\n\t\t\t},\n\t\t\toption(value, content, selected) {\n\t\t\t\treturn this.tag('option', [h.attr('value', value).prop('selected', !!selected), content]);\n\t\t\t},\n\t\t\tscript(src, content) {\n\t\t\t\treturn this.tag('script', [h.attr('src', src).attr('type', 'text/javascript'), content]);\n\t\t\t},\n\t\t\ta() {\n\t\t\t\targuments[0] = h.attr('href', arguments[0]);\n\t\t\t\treturn this.tag('a', arguments);\n\t\t\t},\n\t\t\timg() {\n\t\t\t\targuments[0] = h.attr('src', arguments[0]);\n\t\t\t\treturn this.tag('img', arguments);\n\t\t\t},\n\t\t\tnbsp() {\n\t\t\t\treturn this.text('\\u00A0');\n\t\t\t},\n\t\t\tvisible(yes) {\n\t\t\t\treturn this.style('visibility', yes ? 'visible' : 'hidden');\n\t\t\t},\n\t\t\tdisplay(flag) {\n\t\t\t\treturn this.style('display', typeof flag === 'string' ? flag : (flag ? 'block' : 'none'));\n\t\t\t},\n\t\t\tcontentEditable(opt /*{ value, updateHandler, valueType = \"text\"[|\"html\"|\"integer\"], updateOnEvent = \"blur\", isEditable = true } */ ) {\n\t\t\t\treturn this.prop('contentEditable', opt.isEditable !== false)\n\t\t\t\t\t.prop(opt.valueType === 'html' ? 'innerHTML' : 'textContent', opt.value || '')\n\t\t\t\t\t.on(opt.updateOnEvent || 'blur', (e) => {\n\t\t\t\t\t\topt.updateHandler(castNodeValueTo(e.currentTarget, opt.valueType || 'text'));\n\t\t\t\t\t})\n\t\t\t\t\t.click((e) => {\n\t\t\t\t\t\tif (opt.isEditable !== false) {\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n\nhtmlLexicon.eventsList.forEach((eventName) => {\n\thtmlLexicon.FirstLevel.prototype[eventName] = function(handler, argument) {\n\t\treturn this._append('html', 'on', [eventName, handler, argument]);\n\t};\n});\n\nhtmlLexicon.tagsList.forEach((tagName) => {\n\thtmlLexicon.FirstLevel.prototype[tagName] = function() {\n\t\treturn this._append('html', 'tag', [tagName, arguments]);\n\t};\n});\n\nexport default htmlLexicon;\n\n","/**\n * Todomvc html lexicon (aka web components)\n * @author Gilles Coomans\n */\n\nimport babelute from 'babelute';\nimport htmlLexicon from 'babelute-html/src/html-lexicon';\n\nconst todomvcLexicon = babelute.createLexicon('todomvc', htmlLexicon);\n\ntodomvcLexicon.addCompounds((h) => {\n\treturn {\n\t\t// main entry point\n\t\ttodomvc(todos, route, methods) {\n\n\t\t\tconst visibleTodos = route !== 'all' ? todos.filter((todo) => {\n\t\t\t\treturn (route === 'completed') ? todo.completed : !todo.completed;\n\t\t\t}) : todos;\n\n\t\t\treturn this.div(\n\t\t\t\th.class('todomvc-wrapper')\n\t\t\t\t.section(\n\t\t\t\t\th.id('todoapp').class('todoapp')\n\t\t\t\t\t.todomvcHeader(methods)\n\t\t\t\t\t.section(\n\t\t\t\t\t\th.id('main').class('main').visible(todos.length)\n\t\t\t\t\t\t.toggleAllButton(methods)\n\t\t\t\t\t\t.ul(\n\t\t\t\t\t\t\th.id('todo-list').class('todo-list')\n\t\t\t\t\t\t\t.each(visibleTodos, (todo) => {\n\t\t\t\t\t\t\t\treturn h.todoItem(todo, methods);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.statsSection(todos, route, methods)\n\t\t\t\t)\n\t\t\t\t.todomvcFooter()\n\t\t\t);\n\t\t},\n\t\ttodomvcHeader(methods) {\n\t\t\treturn this.header(\n\t\t\t\th.id('header').class('header')\n\t\t\t\t.h1('Todos')\n\t\t\t\t.textInput('',\n\t\t\t\t\th.id('new-todo').class('new-todo')\n\t\t\t\t\t.attr('placeholder', 'What needs to be done?')\n\t\t\t\t\t.on('keydown', (e) => {\n\t\t\t\t\t\tif (e.keyCode === 13 && e.target.value) {\n\t\t\t\t\t\t\tmethods.append(e.target.value);\n\t\t\t\t\t\t\te.target.value = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\ttoggleAllButton(methods) {\n\t\t\treturn this.checkbox(false,\n\t\t\t\th.id('toggle-all').class('toggle-all')\n\t\t\t\t.attr('name', 'toggle')\n\t\t\t\t.on('click', methods.toggleAll)\n\t\t\t)\n\t\t\t.label(h.attr('for', 'toggle-all'), 'Mark all as complete');\n\t\t},\n\t\ttodoLabel(methods, title, id) {\n\t\t\treturn this.label(title,\n\t\t\t\th.prop('contentEditable', true)\n\t\t\t\t.on('keyup', (e) => {\n\t\t\t\t\tif (e.keyCode === 27) // escape \n\t\t\t\t\t\tmethods.updateTitle(id, title);\n\t\t\t\t\telse //if (e.keyCode === 13 && e.target.value)\n\t\t\t\t\t\tmethods.updateTitle(id, e.target.textContent);\n\t\t\t\t})\n\t\t\t);\n\t\t},\n\t\ttodoItem(todo, methods) {\n\t\t\treturn this.li(\n\t\t\t\th.class('completed', todo.completed)\n\t\t\t\t.div(\n\t\t\t\t\th.class('view')\n\t\t\t\t\t.checkbox(todo.completed, h.class('toggle').on('click', () => methods.toggleComplete(todo.id) ))\n\t\t\t\t\t.todoLabel(methods, todo.title, todo.id)\n\t\t\t\t\t.button(h.class('destroy').on('click', () => methods.delete(todo.id) ))\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\ttodomvcFooter() {\n\t\t\treturn this.footer(\n\t\t\t\th.id('info').class('info')\n\t\t\t\t.p('Written by ', h.a('https://github.com/nomocas', 'nomocas'))\n\t\t\t\t.p('Part of ', h.a('http://todomvc.com', 'TodoMVC'))\n\t\t\t);\n\t\t},\n\t\tstatsSectionNav(route) {\n\t\t\treturn this.ul(\n\t\t\t\th.id('filters').class('filters')\n\t\t\t\t.li(h.a('#/', h.class('selected', route === 'all'), 'All'))\n\t\t\t\t.li(h.a('#/active', h.class('selected', route === 'active'), 'Active'))\n\t\t\t\t.li(h.a('#/completed', h.class('selected', route === 'completed'), 'Completed'))\n\t\t\t);\n\t\t},\n\t\tclearCompletedButton(todosCompleted, methods) {\n\t\t\treturn this.button(\n\t\t\t\th.id('clear-completed').class('clear-completed')\n\t\t\t\t.visible(todosCompleted > 0)\n\t\t\t\t.on('dblclick', methods.clearCompleted),\n\t\t\t\t'Clear completed (' + todosCompleted + ')'\n\t\t\t);\n\t\t},\n\t\tstatsSection(todos, route, methods) {\n\t\t\tconst todosLeft = todos.filter((todo) => {\n\t\t\t\t\treturn !todo.completed;\n\t\t\t\t}).length,\n\t\t\t\ttodosCompleted = todos.length - todosLeft;\n\n\t\t\treturn this.footer(\n\t\t\t\th.id('footer').class('footer')\n\t\t\t\t.visible(todos.length)\n\t\t\t\t.span(\n\t\t\t\t\th.id('todo-count').class('todo-count').strong(todosLeft),\n\t\t\t\t\t(todosLeft === 1 ? ' item' : ' items') + ' left'\n\t\t\t\t)\n\t\t\t\t.statsSectionNav(route)\n\t\t\t\t.clearCompletedButton(todosCompleted, methods)\n\t\t\t);\n\t\t}\n\t};\n});\n\nexport default todomvcLexicon;\n\n","/**\n * Babelute HTML Dom Diffing Pragmatics\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2017 Gilles Coomans\n */\n\nimport htmlLexicon from '../html-lexicon';\nimport bbl from 'babelute';\nimport { insertHTML } from './dom-utils'; // only used in contentEditable. safe for server and string output usage.\n\n/**\n * @external {Pragmatics} https://github.com/nomocas/babelute\n */\n\nconst Scopes = bbl.Scopes,\n\th = htmlLexicon.Atomic.initializer, // only needed for .text() in tag's children\n\t_targets = {\n\t\thtml: true\n\t};\n\n//______________________________________________ RENDER STRATEGY\n\nconst renderActions = {\n\t// Atoms rendering\n\tclass($tag, lexem) {\n\t\tconst args = lexem.args; /* className */\n\t\tif (args[0] && (args.length === 1 || args[1]))\n\t\t\t$tag.classList.add(args[0]);\n\t},\n\tattr($tag, lexem) {\n\t\tconst args = lexem.args; /* name, value */\n\t\t$tag.setAttribute(args[0], args[1]);\n\t},\n\tprop($tag, lexem) {\n\t\tconst args = lexem.args; /* name, value */\n\t\t$tag[args[0]] = args[1];\n\t},\n\tdata($tag, lexem) {\n\t\tconst args = lexem.args; /* name, value */\n\t\t$tag.dataset[args[0]] = args[1];\n\t},\n\tstyle($tag, lexem) {\n\t\tconst args = lexem.args; /* name, value */\n\t\t$tag.style[args[0]] = args[1];\n\t},\n\tid($tag, lexem) {\n\t\t$tag.id = lexem.args[0];\n\t},\n\ton($tag, lexem) {\n\t\tconst args = lexem.args; /* eventName, callback */\n\t\tconst closure = lexem.closure = { handler: args[1] };\n\t\tlexem.listener = function() {\n\t\t\treturn closure.handler.apply(this, arguments);\n\t\t};\n\t\t$tag.addEventListener(args[0], lexem.listener);\n\t},\n\n\t// structural render actions\n\ttag($tag, lexem, scopes, frag) {\n\t\tlexem.child = document.createElement(lexem.args[0]);\n\t\t(frag || $tag).appendChild(lexem.child);\n\t\tconst babelutes = lexem.args[1];\n\t\tfor (let i = 0, len = babelutes.length, babelute; i < len; ++i) {\n\t\t\tbabelute = babelutes[i];\n\t\t\tif (typeof babelute === 'undefined') // cast undefined to '' to keep track of node for diffing\n\t\t\t\tbabelute = '';\n\t\t\tif (!babelute || !babelute.__babelute__) // text node\n\t\t\t\tbabelute = babelutes[i] = h.text(babelute);\n\t\t\trender(lexem.child, babelute, scopes);\n\t\t}\n\t},\n\n\ttext($tag, lexem, scopes, frag) {\n\t\tlexem.child = document.createTextNode(lexem.args[0]);\n\t\t(frag || $tag).appendChild(lexem.child);\n\t},\n\n\tif ($tag, lexem, scopes, frag) {\n\t\tconst toRender = lexem.args[0] ? lexem.args[1] : (lexem.args[2] ? lexem.args[2] : null);\n\t\tif (toRender) {\n\t\t\tlexem.developed = (typeof toRender === 'function') ? toRender() : toRender;\n\t\t\trender($tag, lexem.developed, scopes, frag);\n\t\t}\n\t\tlexem.witness = document.createComment('if');\n\t\t$tag.appendChild(lexem.witness);\n\t},\n\n\teach($tag, lexem, scopes, frag) {\n\t\tconst args = lexem.args;\n\t\tlexem.children = [];\n\t\tconst collection = args[0] = args[0] || [],\n\t\t\titemRender = args[1];\n\t\tfor (let i = 0, len = collection.length, rendered; i < len; ++i) {\n\t\t\trendered = itemRender(collection[i]);\n\t\t\tlexem.children.push(rendered);\n\t\t\trender($tag, rendered, scopes, frag);\n\t\t}\n\t\tlexem.witness = document.createComment('each');\n\t\t$tag.appendChild(lexem.witness);\n\t},\n\n\t// custom output\n\tonDom($tag, lexem, scopes, frag /* args = render, dif, remove */ ) {\n\t\tconst onRender = lexem.args[0];\n\t\tif (onRender)\n\t\t\tonRender($tag, lexem, scopes, frag);\n\t},\n\thtml($tag, lexem) {\n\t\tlexem.children = insertHTML(lexem.args[0], $tag);\n\t}\n};\n\nfunction render($tag, babelute, scopes, frag) {\n\tfor (let i = 0, action, lexem, lexems = babelute._lexems, len = lexems.length; i < len; ++i) {\n\t\tlexem = lexems[i];\n\t\tif (!_targets[lexem.lexicon])\n\t\t\tcontinue;\n\t\taction = renderActions[lexem.name];\n\t\tif (action)\n\t\t\taction($tag, lexem, scopes, frag);\n\t\telse { // no actions means it's a compound lexem : so recursion on first degree dev.\n\t\t\tlexem.developed = bbl.developOneLevel(lexem, _targets[lexem.lexicon]);\n\t\t\trender($tag, lexem.developed, scopes, frag);\n\t\t}\n\t}\n}\n\n//______________________________________________ DIF STRATEGY\n\n/**\n * difActions\n * @public\n * @type {Object}\n */\nconst difActions = {\n\t// structurals\n\tif ($tag, lexem, olexem, scopes) {\n\t\tlexem.witness = olexem.witness;\n\t\tconst args = lexem.args,\n\t\t\toargs = olexem.args;\n\t\tlet toRender;\n\t\tif (!args[0] !== !oargs[0]) { // condition has change\n\t\t\tif (!args[0] || oargs[2]) // if condition was true (there is a success babelute that was rendered) OR it was false and there is an elseBabelute in olexem that was rendered\n\t\t\t\tremove($tag, olexem.developed, scopes); // remove old babelute (either \"success or else\" babelute)\n\t\t\ttoRender = args[0] ? args[1] : args[2]; // if condition is true take \"success babelute\", else take \"else babelute\"\n\t\t\tif (toRender) { // render : add children tags to fragment then add to $tag + add attributes (and co) directly to $tag.\n\t\t\t\tconst frag = document.createDocumentFragment();\n\t\t\t\tlexem.developed = (typeof toRender === 'function') ? toRender() : toRender;\n\t\t\t\trender($tag, lexem.developed, scopes, frag);\n\t\t\t\t$tag.insertBefore(frag, lexem.witness);\n\t\t\t}\n\t\t} else { // no change so dif rendered babelutes\n\t\t\ttoRender = args[0] ? args[1] : args[2];\n\t\t\tif (toRender) {\n\t\t\t\tlexem.developed = (typeof toRender === 'function') ? toRender() : toRender;\n\t\t\t\tdif($tag, lexem.developed, olexem.developed, scopes);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * each\n\t * @public\n\t * @param  {[type]} $tag   [description]\n\t * @param  {[type]} lexem  [description]\n\t * @param  {[type]} olexem [description]\n\t * @param  {[type]} scopes    [description]\n\t * @return {[type]}        [description]\n\t */\n\teach($tag, lexem, olexem, scopes) {\n\t\tconst collection = lexem.args[0],\n\t\t\t// ocollection = olexem.args[0],\n\t\t\trenderItem = lexem.args[1],\n\t\t\tochildren = olexem.children,\n\t\t\tlen = collection.length,\n\t\t\tolen = ochildren.length,\n\t\t\tchildren = lexem.children = new Array(len);\n\n\t\tlet rendered,\n\t\t\tfrag,\n\t\t\titem,\n\t\t\t// notOutOfIndex,\n\t\t\ti = 0;\n\n\t\tlexem.witness = olexem.witness; // keep track of witness\n\n\t\tif (len > olen) // create fragment for new items\n\t\t\tfrag = document.createDocumentFragment();\n\t\tfor (; i < len; ++i) { // for all items (from new lexem)\n\t\t\titem = collection[i];\n\t\t\t// notOutOfIndex = i < olen;\n\t\t\t// if (notOutOfIndex && item === ocollection[i]) { // skip unchanged item\n\t\t\t// \tchildren[i] = ochildren[i]; // keep old rendered\n\t\t\t// \tcontinue;\n\t\t\t// }\n\t\t\trendered = renderItem(item); // render firstdegree item\n\t\t\tchildren[i] = rendered; // keep new rendered\n\t\t\tif (i < olen) // dif existing children\n\t\t\t\tdif($tag, rendered, ochildren[i], scopes);\n\t\t\telse // full render new item and place produced tags in fragment \n\t\t\t\trender($tag, rendered, scopes, frag); // ($tag is forwarded for first level non-tags atoms lexems (aka class, attr, ...))\n\t\t}\n\t\tfor (; i < olen; ++i) // remove not diffed old children\n\t\t\tremove($tag, ochildren[i], scopes);\n\t\tif (frag) // insert new children fragment (if any)\n\t\t\t$tag.insertBefore(frag, lexem.witness);\n\t},\n\n\ttag($tag, lexem, olexem, scopes) {\n\t\tlexem.child = olexem.child; // keep track of elementNode\n\t\tconst babelutes = lexem.args[1],\n\t\t\tobabelutes = olexem.args[1];\n\n\t\tlet babelute, obabelute;\n\t\tfor (let i = 0, len = babelutes.length; i < len; i++) {\n\t\t\t// render all children's babelutes\n\t\t\tbabelute = babelutes[i];\n\t\t\tobabelute = obabelutes[i];\n\t\t\tif (babelute === obabelute)\n\t\t\t\tcontinue;\n\t\t\tif (typeof babelute === 'undefined') // cast undefined to empty string\n\t\t\t\tbabelute = '';\n\t\t\tif (!babelute || !babelute.__babelute__)\n\t\t\t\tbabelute = babelutes[i] = h.text(babelute);\n\t\t\tdif(lexem.child, babelute, obabelute, scopes);\n\t\t}\n\t},\n\n\ttext($tag, lexem, olexem) {\n\n\t\tconst newText = lexem.args[0];\n\n\t\tlexem.child = olexem.child; // keep track of textnode\n\t\tif (newText !== olexem.args[0])\n\t\t\tlexem.child.nodeValue = newText;\n\t},\n\n\t// html simple atoms diffing\n\tclass($tag, lexem, olexem) {\n\n\t\tconst name = lexem.args[0], // new class name\n\t\t\toname = olexem.args[0], // old class name\n\t\t\tflag = lexem.args[1], // new class flag\n\t\t\toflag = olexem.args[1]; // old class flag\n\n\t\tif (name !== oname) {\n\t\t\tif (oname)\n\t\t\t\t$tag.classList.remove(oname);\n\t\t\tif (name && (lexem.args.length === 1 || flag))\n\t\t\t\t$tag.classList.add(name);\n\t\t} else if (name && lexem.args.length > 1 && !flag !== !oflag)\n\t\t\t$tag.classList.toggle(name);\n\t},\n\n\tattr($tag, lexem, olexem) {\n\t\tconst name = lexem.args[0],\n\t\t\tvalue = lexem.args[1],\n\t\t\toname = olexem.args[0],\n\t\t\tovalue = olexem.args[1];\n\n\t\tif (name !== oname) {\n\t\t\t$tag.removeAttribute(oname);\n\t\t\t$tag.setAttribute(name, value);\n\t\t} else if (value !== ovalue)\n\t\t\t$tag.setAttribute(name, value);\n\t},\n\n\tprop($tag, lexem, olexem) {\n\n\t\tconst name = lexem.args[0],\n\t\t\tvalue = lexem.args[1],\n\t\t\toname = olexem.args[0];\n\n\t\tif (name !== oname) {\n\t\t\tdelete $tag[oname];\n\t\t\t$tag[name] = value;\n\t\t} else if (value !== $tag[name] /*olexem.args[1]*/ ) // look diectly in element : for \"checked\" bug (or other properties that change on native interaction with element)\n\t\t\t$tag[name] = value;\n\t},\n\n\tdata($tag, lexem, olexem) {\n\n\t\tconst name = lexem.args[0],\n\t\t\tvalue = lexem.args[1],\n\t\t\toname = olexem.args[0],\n\t\t\tovalue = olexem.args[1];\n\n\t\tif (name !== oname) {\n\t\t\tdelete $tag.dataset[oname];\n\t\t\t$tag.dataset[name] = value;\n\t\t} else if (value !== ovalue)\n\t\t\t$tag.dataset[name] = value;\n\t},\n\n\tstyle($tag, lexem, olexem) {\n\t\tconst name = lexem.args[0],\n\t\t\tvalue = lexem.args[1],\n\t\t\toname = olexem.args[0],\n\t\t\tovalue = olexem.args[1];\n\n\t\tif (name !== oname) {\n\t\t\tdelete $tag.style[oname];\n\t\t\t$tag.style[name] = value;\n\t\t} else if (value !== ovalue)\n\t\t\t$tag.style[name] = value;\n\t},\n\n\tid($tag, lexem, olexem) {\n\t\tconst args = lexem.args;\n\t\tif (args[0] !== olexem.args[0])\n\t\t\t$tag.id = args[0];\n\t},\n\n\ton($tag, lexem, olexem) {\n\t\tconst name = lexem.args[0],\n\t\t\tcallback = lexem.args[1],\n\t\t\targ = lexem.args[2],\n\t\t\toname = olexem.args[0];\n\n\t\tif (name !== oname) {\n\t\t\t$tag.removeEventListener(oname, olexem.listener);\n\t\t\trenderActions.on($tag, lexem);\n\t\t} else {\n\t\t\tlexem.closure = olexem.closure;\n\t\t\tlexem.listener = olexem.listener;\n\t\t\t// if (args[1] !== oargs[1])\n\t\t\tlexem.closure.handler = callback;\n\t\t\tlexem.closure.arg = arg;\n\t\t}\n\t},\n\n\tonDom($tag, lexem, olexem /* args = render, dif, remove */ ) {\n\t\tconst dif = lexem.args[1];\n\t\tif (dif)\n\t\t\tdif($tag, lexem, olexem);\n\t},\n\n\thtml($tag, lexem, olexem) {\n\t\tconst newHTML = lexem.args[0];\n\t\tif (olexem.args[0] !== newHTML) {\n\t\t\tconst lastChild = olexem.children ? olexem.children[olexem.children.length - 1] : null,\n\t\t\t\tnextSibling = lastChild ? lastChild.nextSibling : null;\n\t\t\tolexem.children && olexem.children.forEach((child) => $tag.removeChild(child));\n\t\t\tlexem.children = insertHTML(newHTML, $tag, nextSibling);\n\t\t}\n\t}\n};\n\nfunction dif($tag, babelute, oldb, scopes) {\n\tfor (let lexem, olexem, action, i = 0, len = babelute._lexems.length; i < len; ++i) {\n\t\tlexem = babelute._lexems[i];\n\t\tif (!_targets[lexem.lexicon])\n\t\t\tcontinue;\n\t\tolexem = oldb._lexems[i];\n\t\tif (!lexem.args.length) // wathever lexem is : no args implies never change, so keep old rendered\n\t\t\tlexem.developed = olexem.developed;\n\t\telse {\n\t\t\taction = difActions[lexem.name]; // structural or atom diffing action\n\t\t\tif (action) // let strategy action do the job\n\t\t\t\taction($tag, lexem, olexem, scopes);\n\t\t\telse if (argsChanged(lexem.args, olexem.args)) {\n\t\t\t\t// no action means compounds first degree lexem. so check args dif...\n\t\t\t\tlexem.developed = bbl.developOneLevel(lexem, _targets[lexem.lexicon]);\n\t\t\t\tdif($tag, lexem.developed, olexem.developed, scopes);\n\t\t\t} else // keep old rendered (compounds args haven't changed : so nothing to do)\n\t\t\t\tlexem.developed = olexem.developed;\n\t\t}\n\t}\n}\n\nfunction argsChanged(args, oargs) {\n\tfor (let i = 0, len = args.length; i < len; ++i)\n\t\tif (args[i] !== oargs[i]) // simple reference check : need immutables\n\t\t\treturn true;\n\treturn false;\n}\n\n//______________________________________________ REMOVE STRATEGY\n\nconst removeActions = {\n\tattr($tag, lexem) {\n\t\t$tag.removeAttribute(lexem.args[0]);\n\t},\n\tclass($tag, lexem) {\n\t\tif (lexem.args[0])\n\t\t\t$tag.classList.remove(lexem.args[0]);\n\t},\n\tprop($tag, lexem) {\n\t\tdelete $tag[lexem.args[0]];\n\t},\n\tdata($tag, lexem) {\n\t\tdelete $tag.dataset[lexem.args[0]];\n\t},\n\tstyle($tag, lexem) {\n\t\tdelete $tag.style[lexem.args[0]];\n\t},\n\tid($tag) {\n\t\tdelete $tag.id;\n\t},\n\ton($tag, lexem) {\n\t\t$tag.removeEventListener(lexem.args[0], lexem.listener);\n\t},\n\teach($tag, lexem, scopes) {\n\t\tlexem.children.forEach((child) => remove($tag, child, scopes));\n\t},\n\tonDom($tag, lexem /* render, dif, remove */ ) {\n\t\tconst remove = lexem.args[2];\n\t\tif (remove)\n\t\t\tremove($tag, lexem);\n\t},\n\thtml($tag, lexem) {\n\t\tif (lexem.children)\n\t\t\tlexem.children.forEach((child) => $tag.removeChild(child));\n\t}\n};\n\nfunction remove($tag, babelute, scopes) {\n\tfor (let i = 0, lexems = babelute._lexems, lexem, action, len = lexems.length; i < len; ++i) {\n\t\tlexem = lexems[i];\n\t\tif (!_targets[lexem.lexicon])\n\t\t\tcontinue;\n\t\taction = removeActions[lexem.name];\n\t\tif (action) // class, attr, id, prop, data, each, and .on\n\t\t\taction($tag, lexem, scopes);\n\t\telse if (lexem.developed) { // compounds and if\n\t\t\tremove($tag, lexem.developed, scopes);\n\t\t\tlexem.developed = null;\n\t\t} else if (lexem.child) { // tag and text\n\t\t\t$tag.removeChild(lexem.child);\n\t\t\tlexem.child = null;\n\t\t}\n\t\tif (lexem.witness) // view, if, each\n\t\t\t$tag.removeChild(lexem.witness);\n\t}\n}\n\n//______________________________________________\n\n/**\n * DomDiffing Pragmatics instance\n * @public\n * @type {Pragmatics}\n * @todo  addTargetLexicon(lexicon) => catch name for _targets + store lexicon reference for one level developement : no more need to register lexicons globally\n * @example\n * import difPragmas from 'babelute-html/src/html-to-dom-diffing.js';\n * import htmlLexicon from 'babelute-html/src/html-lexicon.js';\n *\n * const h = htmlLexicon.firstLevelInitializer;\n * let oldRendered, // for diffing tracking\n * \tanimFrame;\n *\n * function update(state) {\n * \tif (animFrame)\n * \t\tcancelAnimationFrame(animFrame);\n * \tanimFrame = requestAnimationFrame(() => {\n * \t\tconst newRendered = h.div(state.intro).section(h.class('my-section').h1(state.title));\n * \t\toldRendered = difPragmas.$output($root, newRendered, oldRendered);\n * \t});\n * }\n * \n * update(myState);\n */\nconst difPragmas = bbl.createPragmatics(_targets, {\n\t$output($tag, babelute, oldBabelute, scopes) {\n\t\tscopes = scopes || new Scopes(this._initScopes ? this._initScopes() : null);\n\t\toldBabelute ? dif($tag, babelute, oldBabelute, scopes) : render($tag, babelute, scopes);\n\t\treturn babelute;\n\t},\n\taddLexicon(lexicon, name) {\n\t\tthis._targets[name || lexicon.name] = lexicon;\n\t\twhile (lexicon.parent) {\n\t\t\tlexicon = lexicon.parent;\n\t\t\tthis._targets[lexicon.name] = lexicon;\n\t\t}\n\t},\n\trender,\n\tdif,\n\tremove,\n\trenderActions,\n\tdifActions,\n\tremoveActions\n});\n\nexport default difPragmas;\n\n","/**s\n * Todomvc : Browser Side Launcher\n * \n * @author Gilles Coomans\n */\n\nimport Todos from './store.js'; // my \"immutable\" store\nimport todomvcLexicon from './todomvc-html-lexicon'; // my custom html lexicon\nimport differ from 'babelute-html/src/pragmatics/html-to-dom-diffing'; // first degree diffing (only for DOM)\n\t\nconst h = todomvcLexicon.firstLevelInitializer,\n\t$root = document.getElementById('todoapp'); // where rendering take place\n\n// don't forget to add your lexicon(s) name to differ\ndiffer.addLexicon(todomvcLexicon);\t\n\n// -------- render ----------\n\nlet oldRendered, // for diffing tracking\n\tanimFrame;\n\n// bind todos update to main render\nTodos.on('update', (state) => {\n\tif (animFrame)\n\t\tcancelAnimationFrame(animFrame);\n\tanimFrame = requestAnimationFrame(() => {\n\t\toldRendered = differ.$output($root, h.todomvc(state.todos, state.route, state.methods), oldRendered);\n\t});\n});\n\n// -------- routes ----------\n\n// simple hashchange binding for routing\nfunction hashChange() {\n\tTodos.route = window.location.hash.substring(2) || 'all';\n\tTodos.emit('update', Todos);\n}\nwindow.onhashchange = hashChange;\n\nhashChange(); // set current route and launch"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","DEFAULT_VALUES","EventEmitter","opts","arguments","undefined","emitDelay","strictMode","hasOwnProperty","_emitDelay","_strictMode","_listeners","events","_addListenner","type","listener","once","indexOf","push","on","off","eventType","listenerFunc","_this","typeIndex","hasType","splice","removedEvents","typeListeners","forEach","fn","idx","unshift","_applyEvents","eventArguments","removableListeners","eeListener","apply","emit","_this2","_len","eventArgs","Array","_key","call","emitSync","_len2","_key2","destroy","module","Todos","proto","title","todos","concat","ID","id","filter","todo","map","assign","completed","methods","bind","Lexem","lexicon","name","args","Babelute","lexems","_lexems","__babelute__","lexiconName","condition","babelute","elseBabelute","array","func","item","index","b","BaseClass","api","B","create","constructor","fromJSON","json","JSON","parse","k","v","lexem","FirstLevel","__first_level_babelute__","lexemName","lexicons","createLexicon","parent","Lexicon","Atomic","initClass","SecondLevel","extends","initializer","firstLevelInitializer","secondLevel","keys","Initializer","atomsArray","addAtom","producer","atomicMethods","secondLevelCompounds","j","getFirstLevelMethod","Error","targets","translate","Class","BaseInitializer","createInitializer","BabeluteClass","Init","_empty","addToInitializer","methodName","getLexicon","registerLexicon","asFirstLevel","_lexicon","_use","use","slice","self","firstLevel","split","value","init","developOneLevel","Pragmatics","pragmas","_targets","addPragmas","createPragmatics","Scopes","scope","pop","FacadePragmatics","subject","scopes","collec","itemHandler","len","templ","$output","createFacadeInitializer","pragmatics","Facade","_subject","_scopes","_append","createFacadePragmatics","insertHTML","content","node","nextSibling","div","document","createElement","elems","wrapped","innerHTML","firstChild","childNodes","frag","createDocumentFragment","el","appendChild","insertBefore","castNodeValueTo","textContent","parseInt","htmlLexicon","atomsList","addAtoms","tagsList","eventsList","addCompounds","tagName","eventName","handler","argument","h","href","rel","tag","attr","link","val","input","checked","prop","selected","src","text","yes","style","flag","opt","isEditable","valueType","updateOnEvent","e","updateHandler","currentTarget","click","preventDefault","stopPropagation","todomvcLexicon","route","visibleTodos","class","section","todomvcHeader","visible","toggleAllButton","ul","each","todoItem","statsSection","todomvcFooter","header","h1","textInput","keyCode","append","checkbox","toggleAll","label","updateTitle","li","toggleComplete","todoLabel","button","delete","footer","p","a","todosCompleted","clearCompleted","todosLeft","span","strong","statsSectionNav","clearCompletedButton","bbl","renderActions","$tag","classList","add","setAttribute","dataset","closure","addEventListener","child","babelutes","createTextNode","toRender","developed","witness","createComment","children","collection","itemRender","rendered","onRender","render","action","difActions","olexem","oargs","ochildren","olen","renderItem","obabelutes","obabelute","newText","nodeValue","oname","remove","oflag","toggle","ovalue","removeAttribute","callback","arg","removeEventListener","dif","newHTML","lastChild","removeChild","oldb","argsChanged","removeActions","difPragmas","oldBabelute","_initScopes","$root","getElementById","differ","addLexicon","oldRendered","animFrame","state","cancelAnimationFrame","requestAnimationFrame","todomvc","hashChange","window","location","hash","substring","onhashchange"],"mappings":"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"}