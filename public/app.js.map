{"version":3,"file":"app.js","sources":["../node_modules/event-emitter-es6/index.js","../src/store.js","../../babelute/src/babelute.js","../../babelute/src/lexicon/first-level.js","../../babelute/src/lexicon/lexicon.js","../../babelute/src/pragmatics/pragmatics-core.js","../../babelute/src/pragmatics/pragmatics-scopes.js","../../babelute/src/pragmatics/facade-pragmatics.js","../../babelute/src/index.js","../../babelute-html/src/pragmatics/dom-utils.js","../../babelute-html/src/html-lexicon.js","../src/todomvc-html-lexicon.js","../../babelute-html/src/pragmatics/html-to-dom-diffing.js","../src/index.js"],"sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DEFAULT_VALUES = {\n    emitDelay: 10,\n    strictMode: false\n};\n\n/**\n * @typedef {object} EventEmitterListenerFunc\n * @property {boolean} once\n * @property {function} fn\n */\n\n/**\n * @class EventEmitter\n *\n * @private\n * @property {Object.<string, EventEmitterListenerFunc[]>} _listeners\n * @property {string[]} events\n */\n\nvar EventEmitter = function () {\n\n    /**\n     * @constructor\n     * @param {{}}      [opts]\n     * @param {number}  [opts.emitDelay = 10] - Number in ms. Specifies whether emit will be sync or async. By default - 10ms. If 0 - fires sync\n     * @param {boolean} [opts.strictMode = false] - is true, Emitter throws error on emit error with no listeners\n     */\n\n    function EventEmitter() {\n        var opts = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_VALUES : arguments[0];\n\n        _classCallCheck(this, EventEmitter);\n\n        var emitDelay = void 0,\n            strictMode = void 0;\n\n        if (opts.hasOwnProperty('emitDelay')) {\n            emitDelay = opts.emitDelay;\n        } else {\n            emitDelay = DEFAULT_VALUES.emitDelay;\n        }\n        this._emitDelay = emitDelay;\n\n        if (opts.hasOwnProperty('strictMode')) {\n            strictMode = opts.strictMode;\n        } else {\n            strictMode = DEFAULT_VALUES.strictMode;\n        }\n        this._strictMode = strictMode;\n\n        this._listeners = {};\n        this.events = [];\n    }\n\n    /**\n     * @protected\n     * @param {string} type\n     * @param {function} listener\n     * @param {boolean} [once = false]\n     */\n\n\n    _createClass(EventEmitter, [{\n        key: '_addListenner',\n        value: function _addListenner(type, listener, once) {\n            if (typeof listener !== 'function') {\n                throw TypeError('listener must be a function');\n            }\n\n            if (this.events.indexOf(type) === -1) {\n                this._listeners[type] = [{\n                    once: once,\n                    fn: listener\n                }];\n                this.events.push(type);\n            } else {\n                this._listeners[type].push({\n                    once: once,\n                    fn: listener\n                });\n            }\n        }\n\n        /**\n         * Subscribes on event type specified function\n         * @param {string} type\n         * @param {function} listener\n         */\n\n    }, {\n        key: 'on',\n        value: function on(type, listener) {\n            this._addListenner(type, listener, false);\n        }\n\n        /**\n         * Subscribes on event type specified function to fire only once\n         * @param {string} type\n         * @param {function} listener\n         */\n\n    }, {\n        key: 'once',\n        value: function once(type, listener) {\n            this._addListenner(type, listener, true);\n        }\n\n        /**\n         * Removes event with specified type. If specified listenerFunc - deletes only one listener of specified type\n         * @param {string} eventType\n         * @param {function} [listenerFunc]\n         */\n\n    }, {\n        key: 'off',\n        value: function off(eventType, listenerFunc) {\n            var _this = this;\n\n            var typeIndex = this.events.indexOf(eventType);\n            var hasType = eventType && typeIndex !== -1;\n\n            if (hasType) {\n                if (!listenerFunc) {\n                    delete this._listeners[eventType];\n                    this.events.splice(typeIndex, 1);\n                } else {\n                    (function () {\n                        var removedEvents = [];\n                        var typeListeners = _this._listeners[eventType];\n\n                        typeListeners.forEach(\n                        /**\n                         * @param {EventEmitterListenerFunc} fn\n                         * @param {number} idx\n                         */\n                        function (fn, idx) {\n                            if (fn.fn === listenerFunc) {\n                                removedEvents.unshift(idx);\n                            }\n                        });\n\n                        removedEvents.forEach(function (idx) {\n                            typeListeners.splice(idx, 1);\n                        });\n\n                        if (!typeListeners.length) {\n                            _this.events.splice(typeIndex, 1);\n                            delete _this._listeners[eventType];\n                        }\n                    })();\n                }\n            }\n        }\n\n        /**\n         * Applies arguments to specified event type\n         * @param {string} eventType\n         * @param {*[]} eventArguments\n         * @protected\n         */\n\n    }, {\n        key: '_applyEvents',\n        value: function _applyEvents(eventType, eventArguments) {\n            var typeListeners = this._listeners[eventType];\n\n            if (!typeListeners || !typeListeners.length) {\n                if (this._strictMode) {\n                    throw 'No listeners specified for event: ' + eventType;\n                } else {\n                    return;\n                }\n            }\n\n            var removableListeners = [];\n            typeListeners.forEach(function (eeListener, idx) {\n                eeListener.fn.apply(null, eventArguments);\n                if (eeListener.once) {\n                    removableListeners.unshift(idx);\n                }\n            });\n\n            removableListeners.forEach(function (idx) {\n                typeListeners.splice(idx, 1);\n            });\n        }\n\n        /**\n         * Emits event with specified type and params.\n         * @param {string} type\n         * @param eventArgs\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(type) {\n            var _this2 = this;\n\n            for (var _len = arguments.length, eventArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                eventArgs[_key - 1] = arguments[_key];\n            }\n\n            if (this._emitDelay) {\n                setTimeout(function () {\n                    _this2._applyEvents.call(_this2, type, eventArgs);\n                }, this._emitDelay);\n            } else {\n                this._applyEvents(type, eventArgs);\n            }\n        }\n\n        /**\n         * Emits event with specified type and params synchronously.\n         * @param {string} type\n         * @param eventArgs\n         */\n\n    }, {\n        key: 'emitSync',\n        value: function emitSync(type) {\n            for (var _len2 = arguments.length, eventArgs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                eventArgs[_key2 - 1] = arguments[_key2];\n            }\n\n            this._applyEvents(type, eventArgs);\n        }\n\n        /**\n         * Destroys EventEmitter\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._listeners = {};\n            this.events = [];\n        }\n    }]);\n\n    return EventEmitter;\n}();\n\nmodule.exports = EventEmitter;\n","/**\n * Simple Naive \"Immutable\" Todo Store.\n * @author Gilles Coomans\n */\n\nimport EventEmitter from 'event-emitter-es6';\n\nconst Todos = new EventEmitter(),\n\tproto = {\n\t\ttodos: [],\n\t\troute: 'all',\n\t\tID: 0,\n\t\tmethods: {\n\t\t\tappend(title) {\n\t\t\t\tthis.todos = this.todos.concat({\n\t\t\t\t\ttitle: title || '',\n\t\t\t\t\tid: this.ID++,\n\t\t\t\t\tcompleted: false\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\tprepend(title) {\n\t\t\t\tthis.todos = [{\n\t\t\t\t\ttitle: title || '',\n\t\t\t\t\tid: this.ID++,\n\t\t\t\t\tcompleted: false\n\t\t\t\t}].concat(this.todos);\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\tdelete(id) {\n\t\t\t\tthis.todos = this.todos.filter((todo) => {\n\t\t\t\t\treturn todo.id !== id;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\ttoggleComplete(id) {\n\t\t\t\tthis.todos = this.todos.map((todo) => {\n\t\t\t\t\tif (todo.id === id) {\n\t\t\t\t\t\ttodo = Object.assign({}, todo);\n\t\t\t\t\t\ttodo.completed = !todo.completed;\n\t\t\t\t\t}\n\t\t\t\t\treturn todo;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\tupdateTitle(id, title) {\n\t\t\t\tthis.todos = this.todos.map((todo) => {\n\t\t\t\t\tif (todo.id === id && todo.title !== title) {\n\t\t\t\t\t\ttodo = Object.assign({}, todo);\n\t\t\t\t\t\ttodo.title = title;\n\t\t\t\t\t}\n\t\t\t\t\treturn todo;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\tclearCompleted() {\n\t\t\t\tthis.todos = this.todos.filter((todo) => {\n\t\t\t\t\treturn !todo.completed;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t},\n\t\t\ttoggleAll() {\n\t\t\t\tthis.todos = this.todos.map((todo) => {\n\t\t\t\t\ttodo = Object.assign({}, todo);\n\t\t\t\t\ttodo.completed = !todo.completed;\n\t\t\t\t\treturn todo;\n\t\t\t\t});\n\t\t\t\tthis.emit('update', this);\n\t\t\t}\n\t\t}\n\t};\n\n// copy proto\nfor (const i in proto)\n\tTodos[i] = proto[i];\n\n// bind all methods to root\nfor (const i in Todos.methods)\n\tTodos.methods[i] = Todos.methods[i].bind(Todos);\n\nexport default Todos;\n\n//","import assert from 'assert'; // removed in production\n/**\n * Babelute core\n *\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\n/**\n * Lexem class : a lexem is just an object containing 3 properties { lexicon:String, name:String, args:Arguments|Array }\n * You should never construct them directly (but if you do babelute's plugins). And it should never be extended.\n * @protected\n */\nexport class Lexem {\n\n\t/**\n\t * construct a new lexem instance\n\t * @param  {String} lexicon the lexicon's name of the lexem\n\t * @param  {String} name    the lexem's name\n\t * @param  {Array|arguments} args  the lexem's arguments (an array or the \"callee arguments\" object) \n\t */\n\tconstructor(lexicon, name, args) {\n\t\tassert(typeof lexicon === 'string' && lexicon.length, 'Lexicon\\'s name should be a valid string');\n\t\tassert(typeof name === 'string' && lexicon.length, 'Lexem\\'s name should be a valid string');\n\t\tassert(Array.isArray(args) || typeof args.length !== 'undefined', 'Lexem\\'s args should be an array (or iterable with bracket access)');\n\n\t\t/**\n\t\t * the lexicon name from where the lexem comes\n\t\t * @type {String}\n\t\t */\n\t\tthis.lexicon = lexicon;\n\n\t\t/**\n\t\t * the lexem's name\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The lexem's arguments array (or arguments object)\n\t\t * @type {Array|arguments}\n\t\t */\n\t\tthis.args = args;\n\t}\n}\n\n/**\n * Babelute Class : just the main helper for writing and holding a babelute sentence. (aka an array of Lexems)\n *\n * Will be the base class for all DSLs handlers.\n *\n * Manage lexems array and lexicon\n * \n * Babelute API and Lexem Naming Conventions : \n * \n * \t\t- any \"meta-language\" method (aka any method that handle the sentence it self - appending new lexem, changing current lexicon, sentences translations, ...) \n * \t\t\tmust start with and underscore : e.g. _append, _lexicon, _if,  _each, _eachLexem, _translate...\n *\n *\t\t- any \"pragmatics output related\" method should start with a '$' and should be named with followed format : e.g. .$myLexiconToMyOutputType(...)\n *\n * \t\t- any DSL lexems (so any other \"api\"'s method) should start with a simple alphabetic char : e.g. .myLexem(), .description(), .title(), ...\n */\n\n/** \n * Class for holding array of lexems\n * @public\n */\nexport class Babelute {\n\n\t/**\n\t * construct a babelute instance\n\t * @param  {?Array} lexems array of lexems for init. (only for internal use)\n\t */\n\tconstructor(lexems = null) {\n\t\tassert(!lexems || Array.isArray(lexems), 'Babelute\\'s constructor accept only an array of lexems as argument (optionaly)');\n\n\t\t/**\n\t\t * the array where lexems are stored\n\t\t * @type {Array}\n\t\t */\n\t\tthis._lexems = lexems || [];\n\n\t\t/**\n\t\t * useful marker for fast instanceof replacement (frame/multiple-js-runtime friendly)\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.__babelute__ = true;\n\t}\n\n\t/**\n\t * The absolute Babelute atom method : add a lexem to babelute's array\n\t * @public\n\t * @param  {String} lexiconName the current lexicon name\n\t * @param  {String} name      the lexem's name\n\t * @param  {Array|arguments} args   the lexem's arguments (either an array or maybe directly the arguments object from when lexem is called)\n\t * @return {Babelute} \tthe current Babelute instance\n\t */\n\t_append(lexiconName, name, args) {\n\n\t\tthis._lexems.push(new Lexem(lexiconName, name, args));\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * conditional sentences concatenation.\n\t *\n\t * Apply modification at sentence writing time (aka the babelute does not contains the _if lexems. _if has immediatly been applied).\n\t * \n\t * @public\n\t * @param  {*} condition any value that will be casted to Boolean (!!)\n\t * @param  {Babelute} babelute  which sentence to insert if !!condition === true\n\t * @param  {?Babelute} elseBabelute  which sentence to insert if !!condition === false\n\t * @return {Babelute}     the current Babelute instance\n\t */\n\t_if(condition, babelute, elseBabelute = null) {\n\n\t\tassert(babelute instanceof Babelute, '._if meta-api need an babelute instance as second argument');\n\t\tassert(!elseBabelute || elseBabelute instanceof Babelute, '._if meta-api need an babelute instance as third argument (optional)');\n\n\t\tif (condition)\n\t\t\tthis._lexems = this._lexems.concat(babelute._lexems);\n\t\telse if (elseBabelute)\n\t\t\tthis._lexems = this._lexems.concat(elseBabelute._lexems);\n\t\treturn this;\n\t}\n\n\t/**\n\t * For each item from array : execute function and concatenate returned babelute sentence to current one. \n\t * Provided function must return a babelute.\n\t *\n\t * Apply modification at sentence writing time (aka the babelute does not contains the _each lexems. _each has immediatly been applied).\n\t * \n\t * @public\n\t * @param  {Array} array  the array to iterate on\n\t * @param  {Function} func the function to handle each item. it must return a babelute.\n\t * @return {Babelute}     the current Babelute instance\n\t */\n\t_each(array, func) {\n\n\t\tassert(Array.isArray(array) || array.length, '._each meta-api need an array (or iterable with bracket access) as first argument');\n\t\tassert(typeof func === 'function', '._each meta-api need a function as second argument');\n\n\t\tarray.forEach((item, index) => {\n\t\t\tconst b = func(item, index);\n\n\t\t\tassert(b instanceof Babelute, '._each need a function that return a babelute');\n\n\t\t\tthis._lexems.push.apply(this._lexems, b._lexems);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a babelute (another sentence) at this point in the current sentence\n\t * @public\n\t * @param  {string|Babelute} babelute Either a string formatted as 'mylexicon:myMethod' (which gives the lexem's method to call), or a Babelute instance (which will be inserted in current sentence)\n\t * @param  {?...args} args the optional arguments to use when calling lexem (only if first argument is a string)\n\t * @return {Babelute} the current Babelute instance\n\t * @throws {Error} If lexicon not found (when first arg is string)\n\t * @throws {Error} If method not found in lexicon (when first arg is string)\n\t */\n\t_use(babelute, ...args) { // eslint-disable-line no-unused-vars\n\t\t// will be implemented in lexicon\n\t}\n\n\n\t/**\n\t * Change current lexicon for next lexems\n\t * @public\n\t * @param  {string} lexiconName the lexicon to use\n\t * @return {Babelute}  a new Babelute from lexicon (i.e. with lexicon's API)\n\t * @throws {Error} If lexicon not found with lexiconName\n\t */\n\t_lexicon(lexiconName) { // eslint-disable-line no-unused-vars\n\t\tassert(typeof lexiconName === 'string', '._lexicon need a string as first argument');\n\t\t// will be implemented in lexicon\n\t}\n\n\t/**\n\t * Create Babelute subclass\n\t * @param  {Babelute} BaseClass the class to be extended\n\t * @param  {?Object} api an object containing methods to add to prototype\n\t * @return {Babelute}   The subclass\n\t * @throws {AssertionError} (only in dev mode) If BaseClass is not a Babelute Subclass (or Babelute)\n\t */\n\tstatic extends(BaseClass, api = null) {\n\t\tassert(BaseClass === Babelute || (BaseClass.prototype instanceof Babelute), 'Babelute.extends accepts only a Babelute Class (or subclass) as first argument');\n\t\tassert(!api || typeof api === 'object', 'Babelute.extends need a (optional) valid object containing methods as second argument');\n\t\tconst B = function(lexems) {\n\t\t\tBaseClass.call(this, lexems);\n\t\t};\n\t\tB.prototype = Object.create(BaseClass.prototype);\n\t\tB.prototype.constructor = B;\n\t\tfor (var i in api) // Object.assign seems to bug when used on prototype (not investigate enough : so use plain old for-in syntax)\n\t\t\tB.prototype[i] = api[i];\n\t\treturn B;\n\t}\n}\n\n\n/**\n * deserialize json to babelute\n * @param  {String} json the json string\n * @return {Babelute}      the deserialized babelute\n * @throws {Error} If json is badly formated\n */\nexport function fromJSON(json) {\n\tassert(typeof json === 'string', 'babelute.fromJSON need a string as first argument');\n\treturn JSON.parse(json, (k, v) => {\n\t\tif (v && v.__babelute__)\n\t\t\treturn new Babelute(v._lexems.map((lexem) => {\n\t\t\t\treturn new Lexem(lexem.lexicon, lexem.name, lexem.args);\n\t\t\t}));\n\t\treturn v;\n\t});\n}\n\n","/**\n * FirstLevel Class : \n *\n * A Babelute subclass aimed to hold only \"first-level\" atoms.\n *\n * Same concept than 'first-level of understanding', as if we where stupid by always understanding only first literal sens of words.\n *\n * It provides sentences and lexems without any interpretation, and that could be really useful : e.g.\n * - to see sentence as \"editable document\" and/or for allowing meta-writing of sentences\n * - to obtain the full AST of babelute sentences \n *\n * See full docs.\n *  \n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\nimport {\n\tBabelute,\n\tLexem\n} from '../babelute.js';\n\n/**\n * FirstLevel Babelute. Exactly same api than corresponing Babelute but where every methods has been replaced by its \"firt-level\" equivalent.\n * @access protected\n */\nexport default class FirstLevel extends Babelute {\n\n\t/**\n\t * construct a firstlevel babelute instance\n\t * @param  {?Array} lexems array of lexems for init. (only for internal use)\n\t */\n\tconstructor(lexems) {\n\t\tsuper(lexems);\n\t\tthis.__first_level_babelute__ = true;\n\t}\n\n\t/**\n\t * return a FirstLevelMethod aka a method that only append an atom (lexicon, name, args)\n\t * @param  {String} lexiconName the lexicon name of the appended atom\n\t * @param  {String} lexemName  the lexem name of the appended atom\n\t * @return {Function}           a function that append the atom\n\t */\n\tstatic getFirstLevelMethod(lexiconName, lexemName) {\n\t\tassert(typeof lexiconName === 'string', 'FirstLevel.getFirstLevelMethod(...) need a string (the lexicon name) as first argument');\n\t\tassert(typeof lexemName === 'string', 'FirstLevel.getFirstLevelMethod(...) need a string (the lexem name) as second argument');\n\t\treturn function () {\n\t\t\tthis._lexems.push(new Lexem(lexiconName, lexemName, arguments));\n\t\t\treturn this;\n\t\t};\n\t}\n}","/**\n * Babelute Lexicon class and helpers.\n *\n * A Lexicon is just an object aimed to handle, store and construct easily a Babelute API \n * and its related FirstLevel/SecondLevel APIs, and their initializers.\n *\n * One DSL = One lexicon.\n *\n * A lexicon could extend another lexicon to manage dialects.\n *\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\n\nimport {\n\tBabelute,\n\tLexem\n} from '../babelute.js';\n\nimport FirstLevel from './first-level.js';\n\n/**\n * Lexicons dico : where to store public lexicon\n * @type {Object}\n * @private\n */\nconst lexicons = {};\n\n/**\n * Way to create lexicon instances\n * @public\n * @param  {string} name   the name of the lexicon\n * @param  {Lexicon} parent a lexicon instance as parent for this one (optional)\n * @return {Lexicon}      a lexicon instance\n */\nfunction createLexicon(name, parent = null) {\n\treturn new Lexicon(name, parent);\n}\n\n/**\n * Lexicon class : helpers to manage Babelute's lexicons\n * @protected\n */\nclass Lexicon {\n\n\t/**\n\t * You should never use frontaly the constructor (aka never use new Lexicon in  your app). Use createLexicon in place.\n\t * \n\t * @param  {string} name   the lexicon name\n\t * @param  {?Lexicon} parent an optional parent lexicon to be extended here\n\t */\n\tconstructor(name, parent = null) {\n\n\t\tassert(typeof name === 'string' && name.length, 'Lexicon constructor need a valid name as first argument'); // all assertions will be removed in production\n\t\tassert(!parent || parent instanceof Lexicon, 'Lexicon constructor second (optional) argument should be another Lexicon that will be used as parent');\n\n\t\t/**\n\t\t * the parent lexicon (if any)\n\t\t * @type {Lexicon}\n\t\t * @protected\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * the lexicon's name\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\t\tparent = parent || {};\n\n\t\t// the three APIs :\n\t\t/**\n\t\t * interpretable sentences API (finally always made from syntactical atoms (aka last level))\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.Atomic = initClass(parent.Atomic || Babelute);\n\t\t/**\n\t\t * \"document\" sentences API (first level : aka all methods has been replaced by fake atomic methods)\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.FirstLevel = initClass(parent.FirstLevel || FirstLevel);\n\t\t/**\n\t\t * AST-provider API aka the whole tree between first level and last level. Never use it directly : its used under the hood by {@link developOneLevel} method.\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.SecondLevel = Babelute.extends(parent.SecondLevel || Babelute);\n\n\t\t/**\n\t\t * the atomic initializer instance\n\t\t * @type {Initializer}\n\t\t */\n\t\tthis.initializer = this.Atomic.initializer;\n\n\t\t/**\n\t\t * the first-level initializer instance\n\t\t * @type {Initializer}\n\t\t */\n\t\tthis.firstLevelInitializer = this.FirstLevel.initializer;\n\n\t\t/**\n\t\t * the secondLevel instance\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.secondLevel = new this.SecondLevel();\n\n\t\tif (parent.Atomic)\n\t\t\tObject.keys(parent.Atomic.initializer)\n\t\t\t.forEach((key) => {\n\t\t\t\taddToInitializer(this.Atomic.Initializer, key);\n\t\t\t\taddToInitializer(this.FirstLevel.Initializer, key);\n\t\t\t});\n\t}\n\n\t/**\n\t * add atomic lexem (atoms) to lexicon\n\t * @param {string[]} atomsArray array of atoms name (as string)\n\t * @return {Lexicon} the lexicon itself\n\t */\n\taddAtoms(atomsArray) {\n\n\t\tassert(Array.isArray(atomsArray), 'lexicon.addAtoms(...) need an array as first argument');\n\n\t\tatomsArray.forEach((name) => addAtom(this, name));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * add compounds lexems to lexicon\n\t * @param {Function} producer a function that take a babelute initializer as argument and that return an object containing methods (lexems) to add to lexicon\n\t * @return {Lexicon} the lexicon itself\n\t */\n\taddCompounds(producer) {\n\n\t\tassert(typeof producer === 'function', 'lexicon.addCompounds(...) need a function (that return an object containing dsl methods) as first argument');\n\n\t\t// Atomic API is produced with Atomic initializer\n\t\tconst atomicMethods = producer(this.Atomic.initializer);\n\n\t\tassert(atomicMethods && typeof atomicMethods === 'object', 'lexicon.addCompounds(function(){...}) need a function that return an object containing dsl methods to add');\n\n\t\tfor (let i in atomicMethods)\n\t\t\tthis.Atomic.prototype[i] = atomicMethods[i];\n\n\t\t// SecondLevel API is simply produced with the related FirstLevel initializer. \n\t\t// (so same producer method, same api, but different handler for inner composition)\n\t\t// is the only thing to do to gain capability to handle full AST. (see docs)\n\t\tconst secondLevelCompounds = producer(this.FirstLevel.initializer);\n\t\tfor (let j in secondLevelCompounds)\n\t\t\tthis.SecondLevel.prototype[j] = secondLevelCompounds[j];\n\n\t\tObject.keys(atomicMethods)\n\t\t\t.forEach((key) => {\n\t\t\t\tthis.FirstLevel.prototype[key] = FirstLevel.getFirstLevelMethod(this.name, key);\n\t\t\t\taddToInitializer(this.Atomic.Initializer, key);\n\t\t\t\taddToInitializer(this.FirstLevel.Initializer, key);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @protected\n\t */\n\tuseAtomic(babelute, name, args) {\n\t\tassert(babelute && babelute.__babelute__, 'lexicon.useAtomic(...) need a babelute intance as first argument');\n\t\tassert(typeof name === 'string', 'lexicon.useAtomic(...) need a string (a method name) as second argument');\n\n\t\tif (!this.Atomic.instance[name])\n\t\t\tthrow new Error(`Babelute (${ this.name }) : method not found : ${ name }`);\n\t\tthis.Atomic.instance[name].apply(babelute, args);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\tuseFirstLevel(babelute, name, args) {\n\t\tassert(babelute && babelute.__babelute__, 'lexicon.useFirstLevel(...) need a babelute intance as first argument');\n\t\tassert(typeof name === 'string', 'lexicon.useFirstLevel(...) need a string (a method name) as second argument');\n\n\t\tif (!this.FirstLevel.instance[name])\n\t\t\tthrow new Error(`Babelute (${ this.name }) : method not found : ${ name }`);\n\t\tthis.FirstLevel.instance[name].apply(babelute, args);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\ttranslateToAtomic(babelute, targets) {\n\t\treturn translate(babelute, this.Atomic, targets || this.targets);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\ttranslateToFirstLevel(babelute, targets) {\n\t\treturn translate(babelute, this.FirstLevel, targets || this.targets);\n\t}\n}\n\n/**\n *  Add syntactical atom lexem to lexicon (actually to inner classes that reflect API). A syntactical Atom method is a function that only add one lexem.\n *  @private\n */\nfunction addAtom(lexicon, name) {\n\tassert(lexicon instanceof Lexicon, 'Lexicon addAtom(...) first argument should be a Lexicon where add syntactical atom');\n\tassert(typeof name === 'string', 'Lexicon addAtom(...) need a string (a method name) as second argument');\n\n\tlexicon.Atomic.prototype[name] = lexicon.FirstLevel.prototype[name] = lexicon.SecondLevel.prototype[name] = FirstLevel.getFirstLevelMethod(lexicon.name, name);\n\taddToInitializer(lexicon.Atomic.Initializer, name);\n\taddToInitializer(lexicon.FirstLevel.Initializer, name);\n}\n\n/**\n * babelute lexicon's Classes initialisation\n * @private\n */\nfunction initClass(BaseClass) {\n\tconst Class = Babelute.extends(BaseClass);\n\tcreateInitializer(Class, BaseClass.Initializer);\n\tClass.instance = new Class();\n\treturn Class;\n}\n\n/**\n * Initializer Class\n * @private\n */\nclass Initializer {\n\tstatic extends(BaseInitializer) {\n\n\t\tassert(BaseInitializer === Initializer || (BaseInitializer.prototype instanceof Initializer), 'Initializer.extends accepts only a Initializer Class (or subclass) as argument');\n\n\t\tconst Class = function() {};\n\t\tClass.prototype = Object.create(BaseInitializer.prototype);\n\t\tClass.prototype.constructor = Class;\n\t\treturn Class;\n\t}\n}\n\n/**\n * create a Initializer (based on a Babelute subclass) and instanciate it\n * @param  {Babelute} BabeluteClass   a Babelute subclass from where create initializer\n * @param  {?Initializer} BaseInitializer a parent initializer to be extended (optional)\n * @return {Initializer}               the Initializer instance\n */\nfunction createInitializer(BabeluteClass, BaseInitializer = null) {\n\n\tassert(BabeluteClass === Babelute || (BabeluteClass.prototype instanceof Babelute), 'Lexicon createInitializer accepts only a Babelute Class (or subclass) as first argument');\n\tassert(!BaseInitializer || BaseInitializer === Initializer || (BaseInitializer.prototype instanceof Initializer), 'Lexicon createInitializer accepts only a Initializer Class (or subclass) as second argument');\n\n\tconst Init = BabeluteClass.Initializer = BaseInitializer ? Initializer.extends(BaseInitializer) : Initializer;\n\tBabeluteClass.initializer = new Init();\n\tBabeluteClass.initializer._empty = function() {\n\t\treturn new BabeluteClass();\n\t};\n\tBabeluteClass.initializer.BabeluteClass = BabeluteClass;\n\tObject.keys(BabeluteClass)\n\t\t.forEach((i) => {\n\t\t\taddToInitializer(Init, i);\n\t\t});\n\treturn BabeluteClass.initializer;\n}\n\n/**\n * add method to initializer\n * @private\n * @param {Initializer} Initializer Initializer class where add methods in proto\n * @param {string} methodName  the name of method to add\n */\nfunction addToInitializer(Initializer, methodName) {\n\tInitializer.prototype[methodName] = function() {\n\t\treturn this.BabeluteClass.prototype[methodName].apply(new this.BabeluteClass(), arguments);\n\t};\n}\n\n\n/**\n * getLexicon registred lexicon by name\n * \n * @param  {string} lexiconName the lexicon's name\n * @return {Lexicon}      the lexicon\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction getLexicon(lexiconName) {\n\tassert(typeof lexiconName === 'string', 'Lexicon.getLexicon(...) need a string (a lexicon name) as first argument');\n\n\tconst lexicon = lexicons[lexiconName];\n\tif (!lexicon)\n\t\tthrow new Error('lexicon not found : ' + lexiconName);\n\treturn lexicon;\n}\n\n/**\n * registerLexicon lexicon by name\n * @param  {Lexicon} lexicon the lexicon instance to registerLexicon\n * @param  {?string} name    lexicon name (optional : if not provided : use the one from lexicon itself)\n */\nfunction registerLexicon(lexicon, name = null) {\n\tassert(lexicon instanceof Lexicon, 'Lexicon.registerLexicon(...) first argument should be a Lexicon');\n\tassert(!name || typeof name === 'string', 'Lexicon.registerLexicon(...) need a string (a lexicon name) as second argument');\n\n\tlexicons[name || lexicon.name] = lexicon;\n}\n\n\n/**\n * Provide Babelute Subclass \"initializer\" object (the one with all the flattened shortcut api for starting sentences easily)\n * @param  {string} lexiconName The lexiconName where catch the Babelute Class from where getLexicon or create the initializer object.\n * @param  {boolean} asFirstLevel true if should return a first-level instance. false to return an atomic instance.\n * @return {Object}   An initializer object with shortcuted API from lexicon's Atomic prototype\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction initializer(lexiconName, asFirstLevel) {\n\tassert(typeof lexiconName === 'string', 'Babelute.initializer(...) accept only a string (a Lexicon id) as argument');\n\tif (!asFirstLevel)\n\t\treturn getLexicon(lexiconName).Atomic.initializer;\n\treturn getLexicon(lexiconName).FirstLevel.initializer;\n}\n\n\n/*\n * _lexicon handeling\n */\n\n// implementation of already declared method in Babelute's proto\nBabelute.prototype._lexicon = function(lexiconName) {\n\tassert(typeof lexiconName === 'string', '._lexicon(...) accept only a string (a Lexicon id) as argument');\n\n\treturn new(getLexicon(lexiconName).Atomic)(this._lexems);\n};\n\nFirstLevel.prototype._lexicon = function(lexiconName) {\n\tassert(typeof lexiconName === 'string', '._lexicon(...) accept only a string (a Lexicon id) as argument');\n\treturn new(getLexicon(lexiconName).FirstLevel)(this._lexems);\n};\n\n\n/**\n * _use handeling\n */\n\n// implementation of already declared method in Babelute's proto\nBabelute.prototype._use = function(babelute /* could be a string in \"lexiconName:methodName\" format */ , ...args) {\n\tassert(!babelute || typeof babelute === 'string' || babelute.__babelute__);\n\treturn babelute ? use(this, babelute, args, false) : this;\n};\n\n// implementation of already declared method in Babelute's proto\nFirstLevel.prototype._use = function(babelute /* could be a string in \"lexiconName:methodName\" format */ /*, ...args */ ) {\n\tassert(!babelute || typeof babelute === 'string' || babelute.__babelute__);\n\treturn babelute ? use(this, babelute, [].slice.call(arguments, 1), true) : this;\n};\n\nfunction use(self, babelute, args, firstLevel) {\n\tif (typeof babelute === 'string') {\n\t\tconst {\n\t\t\tlexiconName,\n\t\t\tmethodName\n\t\t} = babelute.split(':');\n\t\tgetLexicon(lexiconName)[firstLevel ? 'useFirstLevel' : 'useAtomic'](self, methodName, args);\n\t} else if (babelute.__babelute__)\n\t\tself._lexems = self._lexems.concat(babelute._lexems);\n\treturn self;\n}\n\n/**\n * Translation\n */\nfunction translate(babelute, BabeluteClass, targets) {\n\tconst b = new BabeluteClass();\n\tbabelute._lexems.forEach(function(lexem) {\n\t\tif ((targets && !targets[lexem.lexicon]) || this[lexem.name]) // simply forwards lexem (copy) if not in targets\n\t\t\tthis._lexems.push(new Lexem(lexem.lexicon, lexem.name, lexem.args));\n\t\telse\n\t\t\tthis[lexem.name].apply(this, lexem.args.map((value) => {\n\t\t\t\tif (!value || !value.__babelute__)\n\t\t\t\t\treturn value;\n\t\t\t\treturn translate(value, BabeluteClass, targets);\n\t\t\t}));\n\t}, b);\n\treturn b;\n}\n\n/**\n * return a new babelute from needed lexicon\n * @param  {string} lexiconName             the lexicon from where to take api\n * @param  {Boolean} asFirstLevel  True if it needs to return a FirstLevel instance. False or ommitted : returns an Atomic instance.\n * @return {[type]}                  the babelute instance (either an Atomic or a FirstLevel)\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction init(lexiconName, asFirstLevel) {\n\tif (lexiconName)\n\t\treturn new(getLexicon(lexiconName)[asFirstLevel ? 'FirstLevel' : 'Atomic'])();\n\telse if (asFirstLevel)\n\t\treturn new FirstLevel();\n\treturn new Babelute();\n}\n\n/**\n * develop a FirstLevel babelute through SecondLevel API. It means that each lexem will be translate\n * @param  {Lexem} lexem the lexem to develop\n * @return {[type]}       [description]\n * @throws {Error} If lexicon not found with lexem.lexicon\n * @throws {Error} If method not found in lexicon\n */\nfunction developOneLevel(lexem) {\n\tassert(lexem && lexem.__babelutelexem__, 'lexicon.developOneLevel(...) need a lexem intance as first argument');\n\n\tconst lexicon = getLexicon(lexem.lexicon);\n\n\tassert(lexicon.secondLevel[lexem.name], 'lexicon.developOneLevel(...) : lexem\\'s name not found in its own referenced lexicon');\n\n\treturn lexicon.secondLevel[lexem.name].apply(new lexicon.FirstLevel(), lexem.args);\n}\n\nexport {\n\tLexicon,\n\tcreateLexicon,\n\tinit,\n\tgetLexicon,\n\tregisterLexicon,\n\tinitializer,\n\tdevelopOneLevel\n};\n\n","/**\n * Pragmatics Class : minimal abstract class for homogeneous pragmatics.\n *\n * This is the minimal contract that a pragmatics should satisfy.\n */\n\nimport assert from 'assert'; // removed in production\n\n/**\n * Base class to provide homogeneous Pragmatics format. You should never instanciate a Pragmatics directly with new. use {@link createPragmatics}.\n */\nexport class Pragmatics {\n\n\t/**\n\t * @param  {Object} targets initial targets object\n\t * @param  {Object} pragmas pragmatics methods to add\n\t */\n\tconstructor(targets = {}, pragmas = {}) {\n\n\t\tassert(typeof targets === 'object', 'Pragmatics constructor need an object (the lexicons targets) as first argument');\n\t\tassert(typeof pragmas === 'object', 'Pragmatics constructor need an object (the pragma\\'s base methods) as second argument');\n\n\t\t/**\n\t\t * targets holder object\n\t\t * @type {Object}\n\t\t * @public\n\t\t */\n\t\tthis._targets = targets;\n\n\t\tif(pragmas)\n\t\t\tthis.addPragmas(pragmas);\n\t}\n\n\t/**\n\t * add methods to pragmatics instance\n\t * @param {Object} pragmas an object containing methods to add\n\t */\n\taddPragmas(pragmas) {\n\n\t\tassert(pragmas && typeof pragmas === 'object', 'pragmatics.addPragmas(...) need a valid object (the methods map to add) as argument');\n\n\t\tfor (const i in pragmas)\n\t\t\t/**\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tthis[i] = pragmas[i];\n\t}\n\n\t/* istanbul ignore next */\n\t/**\n\t * the method used to output a babelute through this pragmatics instance\n\t * @abstract\n\t */\n\t$output( /* ... */ ) {\n\t\t// to be overridden\n\t\tassert(false, 'pragmatics.$output should implemented in subclasses');\n\t}\n}\n\n/**\n * return a new Pragmatics instance. Do not forget to implement $output before usage.\n * @param  {Object} targets initial targets object\n * @param  {Object} pragmas pragmatics methods to add\n * @return {Pragmatics}   the Pragmatics instance\n */\nexport function createPragmatics(targets = {}, pragmas = {}) {\n\treturn new Pragmatics(targets, pragmas);\n}\n\n","/*******************************************************\n ************** Babelute Acions Environment ************\n *******************************************************/\n/**\n\n *\n */\n\nimport assert from 'assert'; // removed in production\n\n/**\n * Inner-sentence-scopes manager : hold array as stacks for inner-scopes of sentences (if needed). It's only avaiable in pragmatics, while traversing, and is dependent of what pragmatics do. See babelute-html-view as an example of usage.\n *\n * Si its a simple helper aimed to :\n * - give a space where store/access needed variables while interpreting sentences with actions\n * - manage \"inner sentences scopes\" while executing actions tree.\n *\n * It has to be used carefully after reading this :\n *\n * For certain output types (as in Babelute-html diffing) it has to be \"pure\".\n * (in a functional way of thinking).\n * It means that it should contains nothing else \n * than \"local\" variables produced and managed while interpreting sentences.\n * No outside-sentence variables should be needed to perform the output.\n * And so, two output from the same sentence should be the same.\n *\n * So by example, Babelute-html-view use it to keep track (for managing view's life cycle) \n * of views tree while rendering (with the scope facility prodived here).\n * \n * Views are inner-sentences objects, and so as needed, \n * two render on same babelute-html sentence will provide same output.\n *\n * For other DSL and outputs types, it depends what you want and implement, but be sure of what your doing \n * before introducing outside variables dependencies in sentences interpretations.\n */\nexport default class Scopes {\n\n\t/**\n\t * @param  {?Object} scope initial scope object\n\t */\n\tconstructor(scope = {}) {\n\t\t/**\n\t\t * the scopes holder\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.scope = scope;\n\t}\n\n\n\t/**\n\t * push value to scope[name]\n\t * @param  {string} name \tthe scope name\n\t * @param  {*} value \t\tthe value to push\n\t * @return {number}       \tthe new length to be consistent with array push\n\t */\n\tpush(name, value) {\n\t\tassert(typeof name === 'string', 'Pragmatics Scopes .push(...) need a string (the scope name where push) as first argument');\n\t\tassert(typeof value !== 'undefined', 'Pragmatics Scopes .push(...) need a value as second argument');\n\t\tthis.scope[name] = this.scope[name]  || [];\n\t\treturn this.scope[name].push(value);\n\t}\n\n\t/**\n\t * pop value from scope[name]\n\t * @param  {string} name the scope name to pop\n\t * @return {*}      the popped value\n\t */\n\tpop(name) {\n\t\tassert(typeof name === 'string', 'Pragmatics Scopes .pop(...) need a string (the scope name to pop) as first argument');\n\t\tif (!this.scope[name].length)\n\t\t\treturn;\n\t\treturn this.scope[name].pop();\n\t}\n\n\t/**\n\t * get scope value by name\n\t * @param  {string} name the scope name\n\t * @return {*}      the popped scope value\n\t * @throws {Error} If scope not found with name\n\t */\n\tget(name){\n\t\tassert(typeof name === 'string', 'Pragmatics Scopes .get(...) need a string (the scope name where get top value) as first argument');\n\n\t\tvar scope = this.scope[name];\n\t\tif(!scope)\n\t\t\tthrow new Error(`scope not found with : ${ name }`);\n\t\treturn scope[scope.length - 1];\n\t}\n}","import assert from 'assert'; // removed in production\nimport {\n\tBabelute\n} from '../babelute.js';\nimport Scopes from './pragmatics-scopes';\nimport { Pragmatics } from './pragmatics-core.js';\n\n/**\n * FacadePragmatics : a facade oriented Pragmatics subclass. You should never instanciate a FacadePragmatics directly with new. use {@link createFacadePragmatics}.\n * @example\n * // Remarque : any lexem's method will be of the following format : \n * function(subject, args, ?scopes){\n * \t// return nothing\n * }\n */\nexport class FacadePragmatics extends Pragmatics {\n\n\t/**\n\t * @param  {Object} targets initial targets object\n\t * @param  {?Object} pragmas pragmatics methods to add\n\t */\n\tconstructor(targets, pragmas = null) {\n\t\tsuper(targets, pragmas);\n\t}\n\n\t/**\n\t * \"each\" facade implementation\n\t * @param  {Object} subject the handled subject\n\t * @param  {Array|arguments} args  the lexem's args : [ collection:Array, itemHandler:Function ]\n\t * @param  {Scopes} scopes  the sentence's scopes instance\n\t * @return {void}         nothing\n\t */\n\teach(subject, args /* collection, itemHandler */ , scopes) {\n\n\t\tassert(typeof subject === 'object', '.each facade pragma need an object as subject (first argument)');\n\t\tassert(Array.isArray(args[0]) || args[0].length, '.each facade pragma need an array (or iterable with bracket access) as first args object (first argument passed to lexem)');\n\t\tassert(typeof args[1] === 'function', '.each facade pragma need a function as second args object (second argument passed to lexem)');\n\t\tconst collec = args[0],\n\t\t\titemHandler = args[1];\n\n\t\tif (collec.length) // no supputation on collection kind : use \"for\"\n\t\t\tfor (let i = 0, len = collec.length, item, templ; i < len; ++i) {\n\t\t\t\titem = collec[i];\n\t\t\t\ttempl = itemHandler(item, i);\n\t\t\t\tif (templ)\n\t\t\t\t\tthis.$output(subject, templ, scopes);\n\t\t\t}\n\t}\n\n\t/**\n\t * \"if\" facade implementation \n\t * @param  {Object} subject the handled subject\n\t * @param  {Array|arguments} args  the lexem's args : [ conditionIsTrue:Babelute, conditionIsFalse:Babelute ]\n\t * @param  {Scopes} scopes  the sentence's scopes instance\n\t * @return {void}         nothing\n\t */\n\tif (subject, args /* trueBabelute, falseBabelute */ , scopes) {\n\n\t\tassert(typeof subject === 'object', '.if facade pragma need an object as subject (first argument)');\n\t\tassert(args[1] instanceof Babelute, '.if facade pragma need an babelute instance as second args object (second argument passed to lexem)');\n\t\tassert(!args[2] || args[2] instanceof Babelute, '.if facade pragma third args object (third argument passed to lexem) (optional) should be a babelute instance');\n\n\t\tif (args[0])\n\t\t\tthis.$output(subject, args[1], scopes);\n\t\telse if (args[2])\n\t\t\tthis.$output(subject, args[2], scopes);\n\t}\n\n\t/**\n\t *\n\t * @override\n\t * @param  {Object} subject  the subject handle through interpretation\n\t * @param  {Babelute} babelute the babelute \"to interpret on\" subject\n\t * @param  {Scope} scopes   the sentence scopes instance (optional)\n\t * @return {Object}        the subject\n\t */\n\t$output(subject, babelute, scopes = null) {\n\n\t\tassert(typeof subject === 'object', '.$output facade pragma need an object as subject (first argument)');\n\t\tassert(babelute instanceof Babelute, '.$output facade pragma need an babelute instance as second argument');\n\t\tassert(!scopes || typeof scopes === 'object', '.$output facade pragma need an (optional) scope instance as third argument');\n\n\t\tfor (let i = 0, lexem, len = babelute._lexems.length; i < len; ++i) {\n\t\t\tlexem = babelute._lexems[i];\n\t\t\tif (this._targets[lexem.lexicon] && this[lexem.name])\n\t\t\t\tthis[lexem.name](subject, lexem.args, scopes);\n\t\t}\n\t\treturn subject;\n\t}\n}\n\n/**\n * create a facade-ready-to-run initializer function.\n * @param  {Lexicon} lexicon    the lexicon from where take the api\n * @param  {Object} pragmatics   the pragmatics object where to find interpretation method to fire immediatly\n * @return {Function}            the facade initializer function\n * @example\n *\n * import babelute from 'babelute';\n * const myLexicon = babelute.createLexicon('my-lexicon');\n * myLexicon.addAtoms(['foo', 'bar']);\n * \n * const myPragmas = babelute.createFacadePragmatics({\n * \t'my-lexicon':true\n * }, {\n * \tfoo(subject, args, scopes){\n * \t\t// do something\n * \t},\n * \tbar(subject, args, scopes){\n * \t\t// do something\n * \t}\n * });\n *\n * const mlp = babelute.createFacadeInitializer(myLexicon, myPragmas);\n *\n * mlp(mySubject).foo(...).bar(...); // apply pragmas immediatly on subject through lexicon api's\n *\n */\nexport function createFacadeInitializer(lexicon, pragmatics) {\n\tconst Facade = function(subject, scopes) {\n\t\tlexicon.Atomic.call(this);\n\t\tthis._subject = subject;\n\t\tthis._scopes = scopes;\n\t};\n\n\tFacade.prototype = Object.create(lexicon.Atomic.prototype);\n\tFacade.prototype.constructor = Facade;\n\tFacade.prototype._lexicon = null;\n\tFacade.prototype._append = function(lexiconName, name, args) {\n\t\tif ((!pragmatics._targets || pragmatics._targets[lexiconName]) && pragmatics[name])\n\t\t\tpragmatics[name](this._subject, args, this._scopes);\n\t\treturn this;\n\t};\n\treturn (subject, scopes = null) => {\n\t\treturn new Facade(subject, scopes || new Scopes());\n\t};\n}\n\n/**\n * create a FacadePragmatics instance\n * @param  {Object} targets the pragmatics targets DSL\n * @param  {?Object} pragmas the methods to add\n * @return {FacadePragmatics}     the facade pragmatics instance\n * @example\n * const myPragmas = babelute.createFacadePragmatics({\n * \t'my-lexicon':true\n * }, {\n * \tfoo(subject, args, scopes){\n * \t\t// do something\n * \t},\n * \tbar(subject, args, scopes){\n * \t\t// do something\n * \t}\n * });\n */\nexport function createFacadePragmatics(targets, pragmas = null) {\n\treturn new FacadePragmatics(targets, pragmas);\n}\n\n","/*\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016 Gilles Coomans\n */\n\n// core classes and functions\nimport {\n\tBabelute,\n\tLexem,\n\tfromJSON\n} from './babelute.js';\nimport {\n\tcreateLexicon,\n\tinit,\n\tgetLexicon,\n\tregisterLexicon,\n\tinitializer,\n\tdevelopOneLevel\n} from './lexicon/lexicon.js';\nimport { Pragmatics, createPragmatics } from './pragmatics/pragmatics-core.js';\nimport { FacadePragmatics, createFacadeInitializer, createFacadePragmatics } from './pragmatics/facade-pragmatics.js';\nimport Scopes from './pragmatics/pragmatics-scopes.js';\n\nexport default {\n\tcreateLexicon,\n\tcreatePragmatics,\n\tcreateFacadeInitializer,\n\tcreateFacadePragmatics,\n\tinit,\n\tinitializer,\n\tgetLexicon,\n\tregisterLexicon,\n\tdevelopOneLevel,\n\tfromJSON,\n\tBabelute,\n\tLexem,\n\tPragmatics,\n\tFacadePragmatics,\n\tScopes\n};\n\n","/*\n * @Author: Gilles Coomans\n */\n\n/**\n * parse and insert html string in node and return created nodes\n * @param  {[type]} content     [description]\n * @param  {[type]} node        [description]\n * @param  {[type]} nextSibling [description]\n * @return {[type]}             [description]\n */\nfunction insertHTML(content, node, nextSibling) {\n\tif (!content)\n\t\treturn;\n\n\t// TODO: use this in place : still to catch iserted elements and manage buggy text nodes (when html start with text node)\n\t// if(nextSibling)\n\t// \tnextSibling.insertAdjacentHTML('beforebegin', content);\n\t// else\n\t// \tnode.insertAdjacentHTML('beforeend', content)\n\n\tconst div = document.createElement('div'),\n\t\telems = [];\n\tlet wrapped;\n\tif (content[0] !== '<') { // to avoid bug of text node that disapear\n\t\tcontent = '<p>' + content + '</p>';\n\t\twrapped = true;\n\t}\n\tdiv.innerHTML = content;\n\tconst parent = wrapped ? div.firstChild : div,\n\t\tchildNodes = [].slice.call(parent.childNodes);\n\tlet frag;\n\tif (nextSibling)\n\t\tfrag = document.createDocumentFragment();\n\tfor (let i = 0, len = childNodes.length, el; i < len; ++i) {\n\t\tel = childNodes[i];\n\t\telems.push(el);\n\t\t(frag || node).appendChild(el);\n\t}\n\tif (nextSibling)\n\t\tnode.insertBefore(frag, nextSibling);\n\treturn elems;\n}\n\n/**\n * cast inner nod value depending on node value\n * @param  {DomElement} node [description]\n * @param  {String} type the needed type of the value\n * @return {*}     the casted value\n */\nfunction castNodeValueTo(node, type) {\n\tswitch (type) {\n\t\tcase 'text':\n\t\t\treturn node.textContent;\n\t\tcase 'integer':\n\t\t\treturn parseInt(node.textContent, 10);\n\t\tcase 'html':\n\t\t\treturn node.innerHTML;\n\t\tdefault:\n\t\t\tthrow new Error('content editable casting fail : unrecognised rule : ', type);\n\t}\n}\n\nexport {\n\tinsertHTML,\n\tcastNodeValueTo\n};\n\n","/**\n * ***** Babelute HTML5 DSL lexicon *****\n *\n * \n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\nimport { createLexicon } from 'babelute/src/lexicon/lexicon';\nimport { castNodeValueTo } from './pragmatics/dom-utils'; // only used in contentEditable. safe for server and string output usage.\n\n/**\n * html lexicon\n * @type {Lexicon}\n * @public\n * @see  https://github.com/nomocas/babelute-html\n */\nconst htmlLexicon = createLexicon('html');\n\n/*******\n *******\tLANGUAGE ATOMS\n *******/\nhtmlLexicon.addAtoms(['tag', 'attr', 'prop', 'data', 'class', 'id', 'style', 'text', 'on', 'onDom', 'onString', 'if', 'each', 'html']);\n\n/*******\n *******\tCOMPOUNDS WORDS (based on language atoms)\n *******/\n// simple tags (made with .tag) (list should be completed)\nconst tagsList = ['body', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'section', 'span', 'button', 'main', 'article', 'hr', 'header', 'footer', 'label', 'ul', 'li', 'p', 'small', 'b', 'strong', 'i', 'u', 'select', 'title', 'meta'];\n// events (made with .on) (list should be completed)\nconst eventsList = ['click', 'blur', 'focus', 'submit', 'mouseover', 'mousedown', 'mouseup', 'mouseout', 'touchstart', 'touchend', 'touchcancel', 'touchleave', 'touchmove', 'drop', 'dragover', 'dragstart'];\n\nhtmlLexicon.addCompounds(() => {\n\tconst methods = {};\n\ttagsList.forEach((tagName) => {\n\t\tmethods[tagName] = function() {\n\t\t\treturn this._append('html', 'tag', [tagName, arguments]);\n\t\t};\n\t});\n\teventsList.forEach((eventName) => {\n\t\tmethods[eventName] = function(handler, argument) {\n\t\t\treturn this._append('html', 'on', [eventName, handler, argument]);\n\t\t};\n\t});\n\treturn methods;\n})\n.addCompounds((h) => {\n\treturn {\n\t\tlink(href, rel, babelute) {\n\t\t\treturn this.tag('link', [h.attr('href', href).attr('rel', rel), babelute]);\n\t\t},\n\t\tlinkCSS(href) {\n\t\t\treturn this.link(href, 'stylesheet', h.attr('type', 'text/css'));\n\t\t},\n\t\tinput(type, val, babelute) {\n\t\t\treturn this.tag('input', [h.attr('type', type).attr('value', val), babelute]);\n\t\t},\n\t\ttextInput(val, babelute) {\n\t\t\treturn this.input('text', val, babelute);\n\t\t},\n\t\tpasswordInput(val, babelute) {\n\t\t\treturn this.input('password', val, babelute);\n\t\t},\n\t\tcheckbox(checked, babelute) {\n\t\t\treturn this.tag('input', [h.attr('type', 'checkbox').prop('checked', !!checked), babelute]);\n\t\t},\n\t\tradio(checked, babelute) {\n\t\t\treturn this.tag('input', [h.attr('type', 'radio').prop('checked', !!checked), babelute]);\n\t\t},\n\t\toption(value, content, selected) {\n\t\t\treturn this.tag('option', [h.attr('value', value).prop('selected', !!selected), content]);\n\t\t},\n\t\tscript(src, content) {\n\t\t\treturn this.tag('script', [h.attr('src', src).attr('type', 'text/javascript'), content]);\n\t\t},\n\t\ta() {\n\t\t\targuments[0] = h.attr('href', arguments[0]);\n\t\t\treturn this.tag('a', arguments);\n\t\t},\n\t\timg() {\n\t\t\targuments[0] = h.attr('src', arguments[0]);\n\t\t\treturn this.tag('img', arguments);\n\t\t},\n\t\tnbsp() {\n\t\t\treturn this.text('\\u00A0');\n\t\t},\n\t\tvisible(yes) {\n\t\t\treturn this.style('visibility', yes ? 'visible' : 'hidden');\n\t\t},\n\t\tdisplay(flag) {\n\t\t\treturn this.style('display', typeof flag === 'string' ? flag : (flag ? 'block' : 'none'));\n\t\t},\n\t\tcontentEditable(opt /*{ value, updateHandler, valueType = \"text\"[|\"html\"|\"integer\"], updateOnEvent = \"blur\", isEditable = true } */ ) {\n\t\t\treturn this.prop('contentEditable', opt.isEditable !== false)\n\t\t\t\t.prop(opt.valueType === 'html' ? 'innerHTML' : 'textContent', opt.value || '')\n\t\t\t\t.on(opt.updateOnEvent || 'blur', (e) => {\n\t\t\t\t\topt.updateHandler(castNodeValueTo(e.currentTarget, opt.valueType || 'text'));\n\t\t\t\t})\n\t\t\t\t.click((e) => {\n\t\t\t\t\tif (opt.isEditable !== false) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t};\n});\n\nhtmlLexicon.eventsList = eventsList;\nhtmlLexicon.tagsList = tagsList;\n\neventsList.forEach((eventName) => {\n\thtmlLexicon.FirstLevel.prototype[eventName] = function (handler, argument) {\n\t\treturn this._append('html', 'on', [eventName, handler, argument]);\n\t};\n});\ntagsList.forEach((tagName) => {\n\thtmlLexicon.FirstLevel.prototype[tagName] = function () {\n\t\treturn this._append('html', 'tag', [tagName, arguments]);\n\t};\n});\n\nexport default htmlLexicon;\n\n","/**\n * Todomvc html lexicon (aka web components)\n * @author Gilles Coomans\n */\n\nimport babelute from 'babelute';\nimport htmlLexicon from 'babelute-html/src/html-lexicon';\n\nconst todomvcLexicon = babelute.createLexicon('todomvc', htmlLexicon);\n\n// lexicons need to be registred for One-Level-Development (i.e. for diffing)\nbabelute.registerLexicon(htmlLexicon);\nbabelute.registerLexicon(todomvcLexicon);\n\ntodomvcLexicon.addCompounds((h) => {\n\treturn {\n\t\t// main entry point\n\t\ttodomvc(todos, route, methods) {\n\n\t\t\tconst visibleTodos = route !== 'all' ? todos.filter((todo) => {\n\t\t\t\treturn (route === 'completed') ? todo.completed : !todo.completed;\n\t\t\t}) : todos;\n\n\t\t\treturn this.div(\n\t\t\t\th.class('todomvc-wrapper')\n\t\t\t\t.section(\n\t\t\t\t\th.id('todoapp').class('todoapp')\n\t\t\t\t\t.todomvcHeader(methods)\n\t\t\t\t\t.section(\n\t\t\t\t\t\th.id('main').class('main').visible(todos.length)\n\t\t\t\t\t\t.toggleAllButton(methods)\n\t\t\t\t\t\t.ul(\n\t\t\t\t\t\t\th.id('todo-list').class('todo-list')\n\t\t\t\t\t\t\t.each(visibleTodos, (todo) => {\n\t\t\t\t\t\t\t\treturn h.todoItem(todo, methods);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.statsSection(todos, route, methods)\n\t\t\t\t)\n\t\t\t\t.todomvcFooter()\n\t\t\t);\n\t\t},\n\t\ttodomvcHeader(methods) {\n\t\t\treturn this.header(\n\t\t\t\th.id('header').class('header')\n\t\t\t\t.h1('Todos')\n\t\t\t\t.textInput('',\n\t\t\t\t\th.id('new-todo').class('new-todo')\n\t\t\t\t\t.attr('placeholder', 'What needs to be done?')\n\t\t\t\t\t.on('keydown', (e) => {\n\t\t\t\t\t\tif (e.keyCode === 13 && e.target.value) {\n\t\t\t\t\t\t\tmethods.append(e.target.value);\n\t\t\t\t\t\t\te.target.value = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\ttoggleAllButton(methods) {\n\t\t\treturn this.checkbox(false,\n\t\t\t\th.id('toggle-all').class('toggle-all')\n\t\t\t\t.attr('name', 'toggle')\n\t\t\t\t.on('click', methods.toggleAll)\n\t\t\t)\n\t\t\t.label(h.attr('for', 'toggle-all'), 'Mark all as complete');\n\t\t},\n\t\ttodoLabel(methods, title, id) {\n\t\t\treturn this.label(title,\n\t\t\t\th.prop('contentEditable', true)\n\t\t\t\t.on('keyup', (e) => {\n\t\t\t\t\tif (e.keyCode === 27) // escape \n\t\t\t\t\t\tmethods.updateTitle(id, title);\n\t\t\t\t\telse //if (e.keyCode === 13 && e.target.value)\n\t\t\t\t\t\tmethods.updateTitle(id, e.target.textContent);\n\t\t\t\t})\n\t\t\t);\n\t\t},\n\t\ttodoItem(todo, methods) {\n\t\t\treturn this.li(\n\t\t\t\th.class('completed', todo.completed)\n\t\t\t\t.div(\n\t\t\t\t\th.class('view')\n\t\t\t\t\t.checkbox(todo.completed, h.class('toggle').on('click', () => methods.toggleComplete(todo.id) ))\n\t\t\t\t\t.todoLabel(methods, todo.title, todo.id)\n\t\t\t\t\t.button(h.class('destroy').on('click', () => methods.delete(todo.id) ))\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\ttodomvcFooter() {\n\t\t\treturn this.footer(\n\t\t\t\th.id('info').class('info')\n\t\t\t\t.p('Written by ', h.a('https://github.com/nomocas', 'nomocas'))\n\t\t\t\t.p('Part of ', h.a('http://todomvc.com', 'TodoMVC'))\n\t\t\t);\n\t\t},\n\t\tstatsSectionNav(route) {\n\t\t\treturn this.ul(\n\t\t\t\th.id('filters').class('filters')\n\t\t\t\t.li(h.a('#/', h.class('selected', route === 'all'), 'All'))\n\t\t\t\t.li(h.a('#/active', h.class('selected', route === 'active'), 'Active'))\n\t\t\t\t.li(h.a('#/completed', h.class('selected', route === 'completed'), 'Completed'))\n\t\t\t);\n\t\t},\n\t\tclearCompletedButton(todosCompleted, methods) {\n\t\t\treturn this.button(\n\t\t\t\th.id('clear-completed').class('clear-completed')\n\t\t\t\t.visible(todosCompleted > 0)\n\t\t\t\t.on('dblclick', methods.clearCompleted),\n\t\t\t\t'Clear completed (' + todosCompleted + ')'\n\t\t\t);\n\t\t},\n\t\tstatsSection(todos, route, methods) {\n\t\t\tconst todosLeft = todos.filter((todo) => {\n\t\t\t\t\treturn !todo.completed;\n\t\t\t\t}).length,\n\t\t\t\ttodosCompleted = todos.length - todosLeft;\n\n\t\t\treturn this.footer(\n\t\t\t\th.id('footer').class('footer')\n\t\t\t\t.visible(todos.length)\n\t\t\t\t.span(\n\t\t\t\t\th.id('todo-count').class('todo-count').strong(todosLeft),\n\t\t\t\t\t(todosLeft === 1 ? ' item' : ' items') + ' left'\n\t\t\t\t)\n\t\t\t\t.statsSectionNav(route)\n\t\t\t\t.clearCompletedButton(todosCompleted, methods)\n\t\t\t);\n\t\t}\n\t};\n});\n\nexport default todomvcLexicon;\n\n","/**\n * ****** FirstLevel AST diffing ******\n * \n * World's Fastest Diffing algorithm (in many cases ;)).\n * Also one of the lightest and simplest to understand, tweak, maintain, etc.\n *\n * No more esoteric Virtual DOM or diffing algorithm.\n *\n * The only abstract part to understand is the FirstLevel Babelute concept (which is simple by nature. don't panic ;))\n * and the related oneLevelDeveloppement method.\n *\n *\n * First Level refer to \"first level of understanding\", as if every words are understoud only \"literally\".\n * \n * In french there is an expression for this concept which seems to not exists as this in english \n * and which could be translated literally as \"understanding (or expressing) things at first degree\", \"... second degree\", \"... third degree\", ..., \"{x} degree\".\n *\n * We could talk about \"second degree humour\", \n * or say about someone that he \"takes everything at first degree\" (he never understands things deeply or has no sens of humour), \n * or say about a text that it contains multiple \"degree of understanding\".\n *\n * As \"first degree\" in english is understoud as \"the more serious\" or \"the more important\", \n * and as in french it says \"the less understoud\" or \"the more literal\" or \"the most obvious\",\n * I prefer use \"FirstLevel\" to make things clear.\n * \n * A FirstLevel Babelute is a Babelute (a DSL's lexicon) where all \"compounds lexems methods\" are replaced by the \"default atom method\" \n * (aka a method that just append a single lexem with its name as lexem's name and that provide its arguments as lexem's args).\n * So a FirstLevel api signature is exactly the same than it's correspondant Babelute, but every lexem are seen as a syntactical atoms.\n *\n * (see Babelute documentation for more details).\n *\n * One other important things to understand is that it need a \"stable AST\", which means that diffed sentences should be the \"same\" between each rendering (same lexems structure).\n *\n * So, you MUST use .if(condition, babelute, elseBabelute) and .each(array, function(item, index){ return ...a babelute...; }) \n * to forge conditionaly or repeatedly sentences.\n *\n * In other words : do not write :\n *\n * var myBabelute = h.myLexem(...);\n * if(blabla)\n * \t\tmyBabelute.myOtherLexem(...);\n * \telse\n * \t\tmyBabelute.myThirdLexem(...);\n *  myCollection.forEach(function(item){\n *  \tmyBabelute.myFourthLexem(item.title);\n *  });\n *  \n * Which will produce different sentences structures depending on inputs (lexems and arguments are differents).\n * But in place write :\n *\n * h.myLexem(...)\n * .if(blabla, h.myOtherLexem(...), h.myThirdLexem(...))\n * .each(myCollection, function(item){\n * \t\treturn h.myFourthLexem(item.title);\n * });\n *\n * Which will produce the same lexems structure, regardless of the inputs (only arguments change). \n *\n *\n * Algorithmic details\n *\n * Good algorithmic optimisations works by cutting logical tree as high as possible.\n * This one works on the highest avaiable tree : the template's AST.\n * It works by diffing components arguments (dsl's method - aka lexem's - arguments) and by developping lexems \"degree by degree\", only when needed.\n * It allows to keep rendering perf incredibly stable through sequence of modifications and quite independent of DOM nodes quantity.\n * More you have components, more you have nodes, better optimisations you have.\n *\n * Algorithmic performance always depends on inputs set. And this one either.\n * As it constructs and hold the whole template AST at first rendering (the lightest one) \n * in addition to leafs (HTML DSL Atoms - Seen as ours Virtual DOM nodes) and DOM's elements, \n * first rendering is a (really) little bit more consuming than other cutting-edge diffing algorithm \n * that produce only DOM's elements (mythril, vue, plastik, ... -  see benchmark).\n * \n * But this one is much faster after, simply because it rerender and dif only few paths in AST \n * in place of rerendering and diffing big bunchs of (Virtual)DOM's elements.\n *\n * The complexity depends on AST mean path length from root to leaf.\n *\n * One thing fun is that it works as a simple classical diffing algorithm (aka. always rerender all and dif resulted virtual dom) \n * when not used with FirstLevel babelutes (so when used with \"normal\" babelutes). \n * And so the fondamental difference between this algorithm and the classic one is just few lines.\n *\n * \n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2017 Gilles Coomans\n */\n\nimport htmlLexicon from '../html-lexicon';\nimport bbl from 'babelute';\nimport { insertHTML } from './dom-utils'; // only used in contentEditable. safe for server and string output usage.\n\nconst Scopes = bbl.Scopes,\n\th = htmlLexicon.Atomic.initializer, // only needed for .text() in tag's children\n\t_targets = {\n\t\thtml: true\n\t};\n\n//______________________________________________ RENDER STRATEGY\n\nconst renderActions = {\n\t// Atoms rendering\n\tclass($tag, lexem) {\n\t\tconst args = lexem.args; /* className */\n\t\tif (args[0] && (args.length === 1 || args[1]))\n\t\t\t$tag.classList.add(args[0]);\n\t},\n\tattr($tag, lexem) {\n\t\tconst args = lexem.args; /* name, value */\n\t\t$tag.setAttribute(args[0], args[1]);\n\t},\n\tprop($tag, lexem) {\n\t\tconst args = lexem.args; /* name, value */\n\t\t$tag[args[0]] = args[1];\n\t},\n\tdata($tag, lexem) {\n\t\tconst args = lexem.args; /* name, value */\n\t\t$tag.dataset[args[0]] = args[1];\n\t},\n\tstyle($tag, lexem) {\n\t\tconst args = lexem.args; /* name, value */\n\t\t$tag.style[args[0]] = args[1];\n\t},\n\tid($tag, lexem) {\n\t\tconst args = lexem.args; /* value */\n\t\t$tag.id = args[0];\n\t},\n\ton($tag, lexem) {\n\t\tconst args = lexem.args; /* eventName, callback */\n\t\t$tag.addEventListener(args[0], args[1]);\n\t},\n\n\t// structural render actions\n\ttag($tag, lexem, env, frag) {\n\t\tlexem.child = document.createElement(lexem.args[0]);\n\t\t(frag || $tag).appendChild(lexem.child);\n\t\tconst babelutes = lexem.args[1];\n\t\tfor (let i = 0, len = babelutes.length, babelute; i < len; ++i) {\n\t\t\tbabelute = babelutes[i];\n\t\t\tif (typeof babelute === 'undefined') // cast undefined to '' to keep track of node for diffing\n\t\t\t\tbabelute = '';\n\t\t\tif (!babelute || !babelute.__babelute__) // text node\n\t\t\t\tbabelute = babelutes[i] = h.text(babelute);\n\t\t\trender(lexem.child, babelute, env);\n\t\t}\n\t},\n\n\ttext($tag, lexem, env, frag) {\n\t\tlexem.child = document.createTextNode(lexem.args[0]);\n\t\t(frag || $tag).appendChild(lexem.child);\n\t},\n\n\tif ($tag, lexem, env, frag) {\n\t\tconst toRender = lexem.args[0] ? lexem.args[1] : (lexem.args[2] ? lexem.args[2] : null);\n\t\tif (toRender) {\n\t\t\tlexem.developed = (typeof toRender === 'function') ? toRender() : toRender;\n\t\t\trender($tag, lexem.developed, env, frag);\n\t\t}\n\t\tlexem.witness = document.createComment('if');\n\t\t$tag.appendChild(lexem.witness);\n\t},\n\n\teach($tag, lexem, env, frag) {\n\t\tconst args = lexem.args;\n\t\tlexem.children = [];\n\t\tconst collection = args[0] = args[0] || [],\n\t\t\titemRender = args[1];\n\t\tfor (let i = 0, len = collection.length, rendered; i < len; ++i) {\n\t\t\trendered = itemRender(collection[i]);\n\t\t\tlexem.children.push(rendered);\n\t\t\trender($tag, rendered, env, frag);\n\t\t}\n\t\tlexem.witness = document.createComment('each');\n\t\t$tag.appendChild(lexem.witness);\n\t},\n\n\t// custom output\n\tonDom($tag, lexem, env, frag /* args = render, dif, remove */ ) {\n\t\tconst onRender = lexem.args[0];\n\t\tif (onRender)\n\t\t\tonRender($tag, lexem, env, frag);\n\t},\n\thtml($tag, lexem) {\n\t\tlexem.children = insertHTML(lexem.args[0], $tag);\n\t}\n};\n\nfunction render($tag, babelute, env, frag) {\n\tfor (let i = 0, action, lexem, lexems = babelute._lexems, len = lexems.length; i < len; ++i) {\n\t\tlexem = lexems[i];\n\t\tif (!_targets[lexem.lexicon])\n\t\t\tcontinue;\n\t\taction = renderActions[lexem.name];\n\t\tif (action)\n\t\t\taction($tag, lexem, env, frag);\n\t\telse { // no actions means it's a compound lexem : so recursion on first degree dev.\n\t\t\tlexem.developed = bbl.developOneLevel(lexem);\n\t\t\trender($tag, lexem.developed, env, frag);\n\t\t}\n\t}\n}\n\n//______________________________________________ DIF STRATEGY\n\n/**\n * difActions\n * @public\n * @type {Object}\n */\nconst difActions = {\n\t// structurals\n\tif ($tag, lexem, olexem, env) {\n\t\tlexem.witness = olexem.witness;\n\t\tconst args = lexem.args,\n\t\t\toargs = olexem.args;\n\t\tlet toRender;\n\t\tif (!args[0] !== !oargs[0]) { // condition has change\n\t\t\tif (!args[0] || oargs[2]) // if condition was true (there is a success babelute that was rendered) OR it was false and there is an elseBabelute in olexem that was rendered\n\t\t\t\tremove($tag, olexem.developed, env); // remove old babelute (either \"success or else\" babelute)\n\t\t\ttoRender = args[0] ? args[1] : args[2]; // if condition is true take \"success babelute\", else take \"else babelute\"\n\t\t\tif (toRender) { // render : add children tags to fragment then add to $tag + add attributes (and co) directly to $tag.\n\t\t\t\tconst frag = document.createDocumentFragment();\n\t\t\t\tlexem.developed = (typeof toRender === 'function') ? toRender() : toRender;\n\t\t\t\trender($tag, lexem.developed, env, frag);\n\t\t\t\t$tag.insertBefore(frag, lexem.witness);\n\t\t\t}\n\t\t} else { // no change so dif rendered babelutes\n\t\t\ttoRender = args[0] ? args[1] : args[2];\n\t\t\tif (toRender) {\n\t\t\t\tlexem.developed = (typeof toRender === 'function') ? toRender() : toRender;\n\t\t\t\tdif($tag, lexem.developed, olexem.developed, env);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * each\n\t * @public\n\t * @param  {[type]} $tag   [description]\n\t * @param  {[type]} lexem  [description]\n\t * @param  {[type]} olexem [description]\n\t * @param  {[type]} env    [description]\n\t * @return {[type]}        [description]\n\t */\n\teach($tag, lexem, olexem, env) {\n\t\tconst collection = lexem.args[0],\n\t\t\trenderItem = lexem.args[1],\n\t\t\tochildren = olexem.children,\n\t\t\tlen = collection.length,\n\t\t\tolen = ochildren.length,\n\t\t\tchildren = lexem.children = [];\n\t\tlet rendered,\n\t\t\tfrag,\n\t\t\ti = 0;\n\n\t\tlexem.witness = olexem.witness; // keep track of witness\n\t\tif (len > olen) // create fragment for new items\n\t\t\tfrag = document.createDocumentFragment();\n\t\tfor (; i < len; ++i) { // for all items (from new lexem)\n\t\t\trendered = renderItem(collection[i]); // render firstdegree item\n\t\t\tchildren.push(rendered); // keep new rendered\n\t\t\tif (i < olen) // dif existing children\n\t\t\t\tdif($tag, rendered, ochildren[i], env);\n\t\t\telse // full render new item and place produced tags in fragment \n\t\t\t\trender($tag, rendered, env, frag); // ($tag is forwarded for first level non-tags atoms lexems (aka class, attr, ...))\n\t\t}\n\t\tfor (; i < olen; ++i) // remove not diffed old children\n\t\t\tremove($tag, ochildren[i], env);\n\t\tif (frag) // insert new children fragment (if any)\n\t\t\t$tag.insertBefore(frag, lexem.witness);\n\t},\n\n\ttag($tag, lexem, olexem, env) {\n\t\tlexem.child = olexem.child; // keep track of elementNode\n\t\tconst babelutes = lexem.args[1],\n\t\t\tobabelutes = olexem.args[1];\n\t\tlet babelute, obabelute;\n\t\tfor (let i = 0, len = babelutes.length; i < len; i++) {\n\t\t\t// render all children's babelutes\n\t\t\tbabelute = babelutes[i];\n\t\t\tobabelute = obabelutes[i];\n\t\t\tif (babelute === obabelute)\n\t\t\t\tcontinue;\n\t\t\tif (typeof babelute === 'undefined') // cast undefined to empty string\n\t\t\t\tbabelute = '';\n\t\t\tif (!babelute || !babelute.__babelute__)\n\t\t\t\tbabelute = babelutes[i] = h.text(babelute);\n\t\t\tdif(lexem.child, babelute, obabelute, env);\n\t\t}\n\t},\n\n\ttext($tag, lexem, olexem) {\n\t\tlexem.child = olexem.child; // keep track of textnode\n\t\tif (lexem.args[0] !== olexem.args[0])\n\t\t\tlexem.child.nodeValue = lexem.args[0];\n\t},\n\n\t// html simple atoms diffing\n\tclass($tag, lexem, olexem) {\n\t\tconst name = lexem.args[0], // new class name\n\t\t\toname = olexem.args[0], // old class name\n\t\t\tflag = lexem.args[1], // new class flag\n\t\t\toflag = olexem.args[1]; // old class flag\n\t\tif (name !== oname) {\n\t\t\tif (oname)\n\t\t\t\t$tag.classList.remove(oname);\n\t\t\tif (name && (lexem.args.length === 1 || flag))\n\t\t\t\t$tag.classList.add(name);\n\t\t} else if (name && lexem.args.length > 1 && !flag !== !oflag)\n\t\t\t$tag.classList.toggle(name);\n\t},\n\n\tattr($tag, lexem, olexem) {\n\t\tif (lexem.args[0] !== olexem.args[0]) {\n\t\t\t$tag.removeAttribute(olexem.args[0]);\n\t\t\t$tag.setAttribute(lexem.args[0], lexem.args[1]);\n\t\t} else if (lexem.args[1] !== olexem.args[1])\n\t\t\t$tag.setAttribute(lexem.args[0], lexem.args[1]);\n\t},\n\n\tprop($tag, lexem, olexem) {\n\t\tif (lexem.args[0] !== olexem.args[0]) {\n\t\t\tdelete $tag[olexem.args[0]];\n\t\t\t$tag[lexem.args[0]] = lexem.args[1];\n\t\t} else if (lexem.args[1] !== $tag[lexem.args[0]] /*olexem.args[1]*/ ) // look diectly in element : for \"checked\" bug (or other properties that change on native interaction with element)\n\t\t\t$tag[lexem.args[0]] = lexem.args[1];\n\t},\n\n\tdata($tag, lexem, olexem) {\n\t\tif (lexem.args[0] !== olexem.args[0]) {\n\t\t\tdelete $tag.dataset[olexem.args[0]];\n\t\t\t$tag.dataset[lexem.args[0]] = lexem.args[1];\n\t\t} else if (lexem.args[1] !== olexem.args[1])\n\t\t\t$tag.dataset[lexem.args[0]] = lexem.args[1];\n\t},\n\n\tstyle($tag, lexem, olexem) {\n\t\tif (lexem.args[0] !== olexem.args[0]) {\n\t\t\tdelete $tag.style[olexem.args[0]];\n\t\t\t$tag.style[lexem.args[0]] = lexem.args[1];\n\t\t} else if (lexem.args[1] !== olexem.args[1])\n\t\t\t$tag.style[lexem.args[0]] = lexem.args[1];\n\t},\n\n\tid($tag, lexem, olexem) {\n\t\tif (lexem.args[0] !== olexem.args[0])\n\t\t\t$tag.id = lexem.args[0];\n\t},\n\n\ton($tag, lexem, olexem) {\n\t\tif (lexem.args[0] !== olexem.args[0] || lexem.args[1] !== olexem.args[1]) {\n\t\t\t$tag.removeEventListener(olexem.args[0], olexem.args[1]);\n\t\t\t$tag.addEventListener(lexem.args[0], lexem.args[1]);\n\t\t}\n\t},\n\n\tonDom($tag, lexem, olexem /* args = render, dif, remove */ ) {\n\t\tconst dif = lexem.args[1];\n\t\tif (dif)\n\t\t\tdif($tag, lexem, olexem);\n\t},\n\n\thtml($tag, lexem, olexem) {\n\t\tif (olexem.args[0] !== lexem.args[0]) {\n\t\t\tconst lastChild = olexem.children ? olexem.children[olexem.children.length - 1] : null,\n\t\t\t\tnextSibling = lastChild ? lastChild.nextSibling : null;\n\t\t\tolexem.children && olexem.children.forEach((child) => {\n\t\t\t\t$tag.removeChild(child);\n\t\t\t});\n\t\t\tlexem.children = insertHTML(lexem.args[0], $tag, nextSibling);\n\t\t}\n\t}\n};\n\nfunction dif($tag, babelute, oldb, env) {\n\tfor (let lexem, olexem, action, i = 0, len = babelute._lexems.length; i < len; ++i) {\n\t\tlexem = babelute._lexems[i];\n\t\tif (!_targets[lexem.lexicon])\n\t\t\tcontinue;\n\t\tolexem = oldb._lexems[i];\n\t\tif (!lexem.args.length) // wathever lexem is : no args implies never change, so keep old rendered\n\t\t\tlexem.developed = olexem.developed;\n\t\telse {\n\t\t\taction = difActions[lexem.name]; // structural or atom diffing action\n\t\t\tif (action) // let strategy action do the job\n\t\t\t\taction($tag, lexem, olexem, env);\n\t\t\telse if (argsChanged(lexem.args, olexem.args)) {\n\t\t\t\t// no action means compounds first degree lexem. so check args dif...\n\t\t\t\tlexem.developed = bbl.developOneLevel(lexem);\n\t\t\t\tdif($tag, lexem.developed, olexem.developed, env);\n\t\t\t} else // keep old rendered (compounds args haven't changed : so nothing to do)\n\t\t\t\tlexem.developed = olexem.developed;\n\t\t}\n\t}\n}\n\nfunction argsChanged(args, oargs) {\n\tfor (let i = 0, len = args.length; i < len; ++i)\n\t\tif (args[i] !== oargs[i]) // simple reference check : need immutables\n\t\t\treturn true;\n\treturn false;\n}\n\n//______________________________________________ REMOVE STRATEGY\n\nconst removeActions = {\n\tattr($tag, lexem) {\n\t\t$tag.removeAttribute(lexem.args[0]);\n\t},\n\tclass($tag, lexem) {\n\t\tif (lexem.args[0])\n\t\t\t$tag.classList.remove(lexem.args[0]);\n\t},\n\tprop($tag, lexem) {\n\t\tdelete $tag[lexem.args[0]];\n\t},\n\tdata($tag, lexem) {\n\t\tdelete $tag.dataset[lexem.args[0]];\n\t},\n\tstyle($tag, lexem) {\n\t\tdelete $tag.style[lexem.args[0]];\n\t},\n\tid($tag) {\n\t\tdelete $tag.id;\n\t},\n\ton($tag, lexem) {\n\t\t$tag.removeEventListener(lexem.args[0], lexem.listener || lexem.args[1]);\n\t},\n\teach($tag, lexem, scopes) {\n\t\tlexem.children.forEach((child) => {\n\t\t\tremove($tag, child, scopes);\n\t\t});\n\t},\n\tonDom($tag, lexem /* render, dif, remove */ ) {\n\t\tconst remove = lexem.args[2];\n\t\tif (remove)\n\t\t\tremove($tag, lexem);\n\t}\n};\n\nfunction remove($tag, babelute, env) {\n\tfor (let i = 0, lexems = babelute._lexems, lexem, action, len = lexems.length; i < len; ++i) {\n\t\tlexem = lexems[i];\n\t\tif (!_targets[lexem.lexicon])\n\t\t\tcontinue;\n\t\taction = removeActions[lexem.name];\n\t\tif (action) // class, attr, id, prop, data, each, and .on\n\t\t\taction($tag, lexem, env);\n\t\telse if (lexem.developed) { // compounds and if\n\t\t\tremove($tag, lexem.developed, env);\n\t\t\tlexem.developed = null;\n\t\t} else if (lexem.child) { // tag and text\n\t\t\t$tag.removeChild(lexem.child);\n\t\t\tlexem.child = null;\n\t\t}\n\t\tif (lexem.witness) // view, if, each\n\t\t\t$tag.removeChild(lexem.witness);\n\t}\n}\n\n//______________________________________________\n\n/**\n * DomDiffing Pragmatics instance\n * @public\n * @type {Pragmatics}\n * @example\n * import difPragmas from 'babelute-html/src/html-to-dom-diffing.js';\n * import htmlLexicon from 'babelute-html/src/html-lexicon.js';\n *\n * const h = htmlLexicon.firstLevelInitializer;\n * let oldRendered, // for diffing tracking\n * \tanimFrame;\n *\n * function update(state) {\n * \tif (animFrame)\n * \t\tcancelAnimationFrame(animFrame);\n * \tanimFrame = requestAnimationFrame(() => {\n * \t\tconst newRendered = h.div(state.intro).section(h.class('my-section').h1(state.title));\n * \t\toldRendered = difPragmas.$output($root, newRendered, oldRendered);\n * \t});\n * }\n * \n * update(myState);\n */\nconst difPragmas = bbl.createPragmatics(_targets, {\n\t$output($tag, babelute, oldBabelute, env) {\n\t\tenv = env || new Scopes(this._initScopes ? this._initScopes() : null);\n\t\toldBabelute ? dif($tag, babelute, oldBabelute, env) : render($tag, babelute, env);\n\t\treturn babelute;\n\t},\n\trender,\n\tdif,\n\tremove,\n\trenderActions,\n\tdifActions,\n\tremoveActions\n});\n\nexport default difPragmas;\n","/**s\n * Todomvc : Browser Side Launcher\n * \n * @author Gilles Coomans\n */\n\nimport Todos from './store.js'; // my \"immutable\" store\nimport todomvcLexicon from './todomvc-html-lexicon'; // my custom html lexicon\nimport differ from 'babelute-html/src/pragmatics/html-to-dom-diffing'; // first degree diffing (only for DOM)\n\t\nconst h = todomvcLexicon.firstLevelInitializer,\n\t$root = document.getElementById('todoapp'); // where rendering take place\n\n// don't forget to add your lexicon(s) name to differ's _targets\ndiffer._targets.todomvc = true;\t\n\n// -------- render ----------\n\nlet oldRendered, // for diffing tracking\n\tanimFrame;\n\n// bind todos update to main render\nTodos.on('update', (state) => {\n\tif (animFrame)\n\t\tcancelAnimationFrame(animFrame);\n\tanimFrame = requestAnimationFrame(() => {\n\t\toldRendered = differ.$output($root, h.todomvc(state.todos, state.route, state.methods), oldRendered);\n\t});\n});\n\n// -------- routes ----------\n\n// simple hashchange binding for routing\nfunction hashChange() {\n\tTodos.route = window.location.hash.substring(2) || 'all';\n\tTodos.emit('update', Todos);\n}\nwindow.onhashchange = hashChange;\n\nhashChange(); // set current route and launch"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","DEFAULT_VALUES","EventEmitter","opts","arguments","undefined","emitDelay","strictMode","hasOwnProperty","_emitDelay","_strictMode","_listeners","events","_addListenner","type","listener","once","indexOf","push","on","off","eventType","listenerFunc","_this","typeIndex","hasType","splice","removedEvents","typeListeners","forEach","fn","idx","unshift","_applyEvents","eventArguments","removableListeners","eeListener","apply","emit","_this2","_len","eventArgs","Array","_key","call","emitSync","_len2","_key2","destroy","module","Todos","proto","title","todos","concat","ID","id","filter","todo","map","assign","completed","methods","bind","Lexem","lexicon","name","args","Babelute","lexems","_lexems","__babelute__","lexiconName","condition","babelute","elseBabelute","array","func","item","index","b","BaseClass","api","B","create","constructor","fromJSON","json","JSON","parse","k","v","lexem","FirstLevel","__first_level_babelute__","lexemName","lexicons","createLexicon","parent","Lexicon","Atomic","initClass","SecondLevel","extends","initializer","firstLevelInitializer","secondLevel","keys","Initializer","atomsArray","addAtom","producer","atomicMethods","secondLevelCompounds","j","getFirstLevelMethod","Error","targets","translate","Class","BaseInitializer","createInitializer","BabeluteClass","Init","_empty","addToInitializer","methodName","getLexicon","registerLexicon","asFirstLevel","_lexicon","_use","use","slice","self","firstLevel","split","value","init","developOneLevel","Pragmatics","pragmas","_targets","addPragmas","createPragmatics","Scopes","scope","pop","FacadePragmatics","subject","scopes","collec","itemHandler","len","templ","$output","createFacadeInitializer","pragmatics","Facade","_subject","_scopes","_append","createFacadePragmatics","insertHTML","content","node","nextSibling","div","document","createElement","elems","wrapped","innerHTML","firstChild","childNodes","frag","createDocumentFragment","el","appendChild","insertBefore","castNodeValueTo","textContent","parseInt","htmlLexicon","addAtoms","tagsList","eventsList","addCompounds","tagName","eventName","handler","argument","h","href","rel","tag","attr","link","val","input","checked","prop","selected","src","text","yes","style","flag","opt","isEditable","valueType","updateOnEvent","e","updateHandler","currentTarget","click","preventDefault","stopPropagation","todomvcLexicon","route","visibleTodos","class","section","todomvcHeader","visible","toggleAllButton","ul","each","todoItem","statsSection","todomvcFooter","header","h1","textInput","keyCode","append","checkbox","toggleAll","label","updateTitle","li","toggleComplete","todoLabel","button","delete","footer","p","a","todosCompleted","clearCompleted","todosLeft","span","strong","statsSectionNav","clearCompletedButton","bbl","renderActions","$tag","classList","add","setAttribute","dataset","addEventListener","env","child","babelutes","createTextNode","toRender","developed","witness","createComment","children","collection","itemRender","rendered","onRender","render","action","difActions","olexem","oargs","renderItem","ochildren","olen","obabelutes","obabelute","nodeValue","oname","remove","oflag","toggle","removeAttribute","removeEventListener","dif","lastChild","removeChild","oldb","argsChanged","removeActions","difPragmas","oldBabelute","_initScopes","$root","getElementById","differ","todomvc","oldRendered","animFrame","state","cancelAnimationFrame","requestAnimationFrame","hashChange","window","location","hash","substring","onhashchange"],"mappings":"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"}